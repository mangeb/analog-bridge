/**
 *  Analog Bridge — Web Server Implementation
 *
 *  WiFi AP mode by default. ESPAsyncWebServer serves:
 *    GET /     → gzipped dashboard HTML (from web_data.h)
 *    WS  /ws   → real-time sensor JSON at 5Hz
 */
#include "web_server.h"
#include "config.h"
#include <WiFi.h>
#include <ESPAsyncWebServer.h>
#include <ESPmDNS.h>

// Generated by web-ui build pipeline (gzip → C array)
// Placeholder until the real UI is built
#include "web_data.h"

static AsyncWebServer server(80);
static AsyncWebSocket ws("/ws");

//----------------------------------------------------------------
// WebSocket event handler
//----------------------------------------------------------------
static void onWsEvent(AsyncWebSocket *server, AsyncWebSocketClient *client,
                      AwsEventType type, void *arg, uint8_t *data, size_t len) {
  switch (type) {
    case WS_EVT_CONNECT:
      Serial.printf("INF: WebSocket client #%u connected from %s\n",
        client->id(), client->remoteIP().toString().c_str());
      break;
    case WS_EVT_DISCONNECT:
      Serial.printf("INF: WebSocket client #%u disconnected\n", client->id());
      break;
    case WS_EVT_ERROR:
      Serial.printf("WRN: WebSocket error on client #%u\n", client->id());
      break;
    case WS_EVT_DATA:
      // Client-to-server messages (future: remote commands)
      break;
    default:
      break;
  }
}

//----------------------------------------------------------------
// Public API
//----------------------------------------------------------------

void webInit() {
  // Build SSID with last 4 hex of MAC for uniqueness
  uint8_t mac[6];
  WiFi.macAddress(mac);
  char ssid[32];
  snprintf(ssid, sizeof(ssid), "%s-%02X%02X",
    WIFI_AP_SSID_PREFIX, mac[4], mac[5]);

  // Start WiFi AP
  WiFi.mode(WIFI_AP);
  WiFi.softAP(ssid, WIFI_AP_PASSWORD, WIFI_AP_CHANNEL, 0, WIFI_AP_MAX_CLIENTS);
  delay(100);  // Let AP stabilize

  Serial.printf("INF: WiFi AP started — SSID: %s\n", ssid);
  Serial.printf("INF: Dashboard: http://%s/\n", WiFi.softAPIP().toString().c_str());

  // mDNS — access via http://analogbridge.local/
  if (MDNS.begin("analogbridge")) {
    Serial.println("INF: mDNS: http://analogbridge.local/");
    MDNS.addService("http", "tcp", 80);
  }

  // Serve gzipped HTML dashboard
  server.on("/", HTTP_GET, [](AsyncWebServerRequest *request) {
    AsyncWebServerResponse *response = request->beginResponse(
      200, "text/html", index_html_gz, index_html_gz_len);
    response->addHeader("Content-Encoding", "gzip");
    request->send(response);
  });

  // Health check endpoint (useful for testing)
  server.on("/api/status", HTTP_GET, [](AsyncWebServerRequest *request) {
    char json[128];
    snprintf(json, sizeof(json),
      "{\"fw\":\"%s\",\"heap\":%d,\"uptime\":%lu,\"clients\":%d}",
      FW_VERSION, ESP.getFreeHeap(), millis() / 1000, ws.count());
    request->send(200, "application/json", json);
  });

  // WebSocket
  ws.onEvent(onWsEvent);
  server.addHandler(&ws);

  server.begin();
  Serial.println("INF: Web server started on port 80");
}

void webBroadcast(const SensorData &data, bool isRecording,
                  const char* filename, unsigned long rowCount,
                  float duration, uint16_t keyframeCount) {
  if (ws.count() == 0) return;  // No clients, skip serialization

  // Build JSON payload (~350 bytes)
  char json[512];
  int len = snprintf(json, sizeof(json),
    "{\"t\":%.3f,"
    "\"gps\":{\"lat\":%.7f,\"lon\":%.7f,\"spd\":%.1f,\"alt\":%.0f,\"dir\":%.0f,\"sat\":%d,\"stale\":%s},"
    "\"imu\":{\"ax\":%.2f,\"ay\":%.2f,\"az\":%.2f,\"gx\":%.1f,\"gy\":%.1f,\"gz\":%.1f,"
            "\"mx\":%.0f,\"my\":%.0f,\"mz\":%.0f,\"tmp\":%.1f},"
    "\"eng\":{\"afr\":%.1f,\"afr1\":%.1f,\"vss\":%.1f,\"map\":%.1f,\"oil\":%.0f,\"clt\":%.0f},"
    "\"rec\":{\"on\":%s,\"file\":\"%s\",\"rows\":%lu,\"dur\":%.1f,\"kf\":%d}}",
    (float)millis() / 1000.0f,
    // GPS — convert degE7 back to float for JSON
    (double)data.lat / 1e7, (double)data.lon / 1e7,
    data.speed, data.alt, data.dir, data.satellites,
    data.gpsStale ? "true" : "false",
    // IMU
    data.accx, data.accy, data.accz,
    data.rotx, data.roty, data.rotz,
    data.magx, data.magy, data.magz, data.imuTemp,
    // Engine
    data.afr, data.afr1, data.vss, data.map, data.oilp, data.coolant,
    // Recording
    isRecording ? "true" : "false",
    filename ? filename : "",
    rowCount, duration, keyframeCount
  );

  ws.textAll(json, len);
}

int webGetClientCount() {
  return ws.count();
}

void webCleanup() {
  ws.cleanupClients();
}
