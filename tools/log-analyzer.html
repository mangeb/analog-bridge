<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Log Analyzer — 1969 Nova 454 BBC</title>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/4.4.0/chart.umd.js"></script>
<style>
* { box-sizing: border-box; margin: 0; padding: 0; }
body { font-family: -apple-system, 'Segoe UI', Arial, sans-serif; background: #1a1a2e; color: #e0e0e0; min-height: 100vh; display: flex; justify-content: center; padding: 16px; }
.container { max-width: 900px; width: 100%; }
h1 { font-size: 1.4rem; color: #4fc3f7; margin-bottom: 2px; }
.subtitle { color: #888; font-size: 0.82rem; margin-bottom: 14px; }
.card { background: #16213e; border-radius: 10px; padding: 16px; margin-bottom: 12px; border: 1px solid #1a3a5c; }
.card h2 { font-size: 0.95rem; color: #4fc3f7; margin-bottom: 10px; border-bottom: 1px solid #1a3a5c; padding-bottom: 6px; }
.hidden { display: none !important; }

/* Upload */
.upload-zone { border: 2px dashed #2a4a6c; border-radius: 10px; padding: 40px; text-align: center; cursor: pointer; transition: border-color 0.2s, background 0.2s; }
.upload-zone:hover, .upload-zone.dragover { border-color: #4fc3f7; background: rgba(79,195,247,0.05); }
.upload-zone .icon { font-size: 2rem; margin-bottom: 8px; color: #4fc3f7; }
.upload-zone p { color: #888; font-size: 0.85rem; }
.upload-zone .hint { font-size: 0.75rem; color: #555; margin-top: 6px; }

/* Dashboard */
.dash-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 10px; text-align: center; }
.dash-item .val { font-size: 1.6rem; font-weight: 700; color: #fff; }
.dash-item .lbl { font-size: 0.7rem; color: #888; margin-top: 2px; }
.dash-item.cond .val { font-size: 1rem; }

/* Playback */
.playback { display: flex; align-items: center; gap: 10px; flex-wrap: wrap; }
.playback button { background: #0f1a30; border: 1px solid #2a4a6c; color: #e0e0e0; padding: 6px 14px; border-radius: 5px; cursor: pointer; font-size: 0.85rem; }
.playback button:hover { border-color: #4fc3f7; color: #4fc3f7; }
.playback button.active { background: #1a3a5c; border-color: #4fc3f7; color: #4fc3f7; }
.time-display { font-size: 0.85rem; color: #ccc; font-variant-numeric: tabular-nums; min-width: 120px; }
.scrubber { flex: 1; min-width: 150px; -webkit-appearance: none; background: #0f1a30; height: 6px; border-radius: 3px; outline: none; }
.scrubber::-webkit-slider-thumb { -webkit-appearance: none; width: 14px; height: 14px; border-radius: 50%; background: #4fc3f7; cursor: pointer; }
.speed-sel { background: #0f1a30; border: 1px solid #2a4a6c; color: #ccc; padding: 4px 8px; border-radius: 4px; font-size: 0.8rem; }

/* Channels */
.ch-bar { display: flex; flex-wrap: wrap; gap: 4px; margin-bottom: 8px; }
.ch-bar label { font-size: 0.75rem; color: #888; display: flex; align-items: center; gap: 3px; cursor: pointer; padding: 2px 6px; border-radius: 3px; border: 1px solid transparent; }
.ch-bar label:hover { border-color: #2a4a6c; }
.ch-bar input { width: auto; }

/* Chart */
.chart-wrap { position: relative; width: 100%; height: 280px; }
.chart-wrap canvas { width: 100% !important; height: 100% !important; }

/* AFR Gauge — Combined is hero, banks are secondary */
.afr-hero { display: flex; align-items: center; gap: 14px; margin-bottom: 6px; }
.afr-hero .reading { font-size: 2rem; font-weight: 700; color: #fff; min-width: 70px; }
.afr-hero .bar-bg { flex: 1; height: 20px; background: #0f1a30; border-radius: 4px; position: relative; overflow: hidden; }
.afr-hero .bar-fill { height: 100%; border-radius: 4px; transition: width 0.15s, background 0.15s; }
.afr-hero .target-line { position: absolute; top: 0; height: 100%; width: 2px; background: #fff; opacity: 0.7; z-index: 2; }
.afr-hero .target-zone { position: absolute; top: 0; height: 100%; background: rgba(255,255,255,0.08); border-left: 1px dashed rgba(255,255,255,0.3); border-right: 1px dashed rgba(255,255,255,0.3); z-index: 1; }
.afr-banks { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; opacity: 0.55; transition: opacity 0.2s; }
.afr-banks:hover { opacity: 0.9; }
.afr-banks .label { font-size: 0.7rem; color: #666; margin-bottom: 2px; }
.afr-banks .bar-bg { height: 10px; background: #0f1a30; border-radius: 3px; position: relative; overflow: hidden; }
.afr-banks .bar-fill { height: 100%; border-radius: 3px; transition: width 0.15s, background 0.15s; }
.afr-banks .reading { font-size: 0.85rem; color: #999; margin-top: 2px; }
.cond-row { display: flex; align-items: center; gap: 12px; margin-top: 8px; }
.cond-badge { padding: 4px 12px; border-radius: 4px; font-size: 0.8rem; font-weight: 600; }
.cond-target { font-size: 0.8rem; color: #888; }
.cond-status { font-size: 0.8rem; font-weight: 600; }

/* Condition legend */
.cond-legend { display: flex; flex-wrap: wrap; gap: 6px; margin-top: 8px; }
.cond-legend-item { display: flex; align-items: center; gap: 4px; font-size: 0.7rem; color: #888; }
.cond-dot { width: 10px; height: 10px; border-radius: 2px; }

/* Section collapse toggle */
.card-header { display: flex; justify-content: space-between; align-items: center; cursor: pointer; user-select: none; }
.card-header h2 { margin-bottom: 0; border-bottom: none; padding-bottom: 0; }
.card-header .toggle-arrow { font-size: 0.7rem; color: #555; transition: transform 0.2s; }
.card-header .toggle-arrow.open { transform: rotate(90deg); }
.card-body { overflow: hidden; transition: max-height 0.3s ease; }
.card-body.collapsed { max-height: 0 !important; padding-top: 0; padding-bottom: 0; }
.card-summary { font-size: 0.85rem; color: #ccc; margin-top: 6px; }
.card-summary.hidden { display: none !important; }
.card-summary:not(.hidden) { display: block !important; }

/* Traction / filter indicators */
.filter-bar { display: flex; flex-wrap: wrap; gap: 8px; align-items: center; margin-bottom: 8px; }
.filter-bar label { font-size: 0.75rem; color: #888; display: flex; align-items: center; gap: 4px; cursor: pointer; }
.filter-bar input { width: auto; }
.traction-warn { display: inline-flex; align-items: center; gap: 4px; padding: 2px 8px; border-radius: 3px; font-size: 0.75rem; font-weight: 600; }
.traction-warn.slip { background: rgba(255,82,82,0.15); color: #ff5252; }
.traction-warn.ok { background: rgba(102,187,106,0.1); color: #66bb6a; }

/* Map */
#mapContainer { width: 100%; height: 320px; border-radius: 8px; overflow: hidden; }
.map-controls { display: flex; align-items: center; gap: 10px; margin-bottom: 8px; }
.map-controls label { font-size: 0.8rem; color: #888; }
.map-controls select { background: #0f1a30; border: 1px solid #2a4a6c; color: #ccc; padding: 4px 8px; border-radius: 4px; font-size: 0.8rem; }

/* Collapsible */
details { margin-bottom: 12px; }
details > summary { background: #16213e; border: 1px solid #1a3a5c; border-radius: 10px; padding: 10px 16px; cursor: pointer; font-size: 0.9rem; color: #4fc3f7; font-weight: 500; list-style: none; display: flex; justify-content: space-between; align-items: center; }
details > summary::-webkit-details-marker { display: none; }
details > summary::after { content: '\25B8'; font-size: 0.8rem; color: #555; transition: transform 0.2s; }
details[open] > summary::after { transform: rotate(90deg); }
details[open] > summary { border-radius: 10px 10px 0 0; }
.panel { background: #16213e; border: 1px solid #1a3a5c; border-top: none; border-radius: 0 0 10px 10px; padding: 14px; }

/* Smoothing */
.smooth-row { display: flex; align-items: center; gap: 12px; }
.smooth-row label { font-size: 0.8rem; color: #888; }
.smooth-row input[type=range] { width: 120px; }
.smooth-row .val { font-size: 0.8rem; color: #4fc3f7; min-width: 30px; }

/* Tables */
table { width: 100%; border-collapse: collapse; font-size: 0.8rem; }
th { color: #4fc3f7; text-align: right; padding: 4px 8px; border-bottom: 1px solid #1a3a5c; }
th:first-child { text-align: left; }
td { text-align: right; padding: 4px 8px; color: #ccc; }
td:first-child { text-align: left; color: #aaa; }

/* AFR Heatmap */
.heatmap-wrap { position: relative; }
#afrHeatmap { width: 100%; border-radius: 6px; }
.heatmap-info { display: flex; justify-content: space-between; align-items: center; margin-top: 6px; font-size: 0.75rem; color: #888; }
.heatmap-legend { display: flex; align-items: center; gap: 4px; }
.heatmap-legend-bar { width: 120px; height: 8px; border-radius: 3px; }
.heatmap-cur { font-size: 0.8rem; color: #ccc; font-variant-numeric: tabular-nums; }

/* G-G diagram */
.gg-wrap { position: relative; width: 360px; flex-shrink: 0; }
.gg-wrap canvas { width: 100% !important; }
.gg-stats table { width: 100%; font-size: 0.78rem; }
.gg-stats td { padding: 3px 6px; color: #ccc; }
.gg-stats td:first-child { color: #888; }
.gg-stats .stat-val { font-weight: 600; font-variant-numeric: tabular-nums; }

/* Values panel */
.vals-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 6px; font-size: 0.75rem; }
.vals-grid .vl { color: #888; }
.vals-grid .vv { color: #ccc; font-weight: 500; }

/* Engine sound controls */
.sound-controls { display: flex; align-items: center; gap: 8px; margin-top: 6px; border-top: 1px solid #1a3a5c; padding-top: 8px; }
.sound-controls button { background: #0f1a30; border: 1px solid #2a4a6c; color: #e0e0e0; padding: 4px 10px; border-radius: 5px; cursor: pointer; font-size: 0.78rem; }
.sound-controls button:hover { border-color: #4fc3f7; color: #4fc3f7; }
.sound-controls button.snd-on { background: #1a3a5c; border-color: #ffa726; color: #ffa726; }
.sound-controls label { font-size: 0.75rem; color: #888; display: flex; align-items: center; gap: 4px; }
.sound-controls input[type=range] { width: 70px; }
.sound-controls .rpm-readout { font-size: 0.8rem; font-weight: 600; color: #ffa726; font-variant-numeric: tabular-nums; min-width: 70px; }
</style>
</head>
<body>
<div class="container">
  <h1>Log Analyzer</h1>
  <p class="subtitle">1969 Nova 454 BBC — Analog Bridge Datalogger</p>

  <!-- Upload -->
  <div class="card" id="uploadCard">
    <div class="upload-zone" id="uploadZone">
      <div class="icon">&#128190;</div>
      <p>Drop a CSV log file here, or click to browse</p>
      <p class="hint">25-column Analog Bridge CSV at 12.5 Hz</p>
      <input type="file" id="fileInput" accept=".csv" style="display:none">
    </div>
  </div>

  <!-- Everything below hidden until file loaded -->
  <div id="mainUI" class="hidden">

    <!-- Dashboard -->
    <div class="card dash">
      <div class="dash-grid">
        <div class="dash-item"><div class="val" id="dDuration">—</div><div class="lbl">Duration</div></div>
        <div class="dash-item"><div class="val" id="dRows">—</div><div class="lbl">Rows</div></div>
        <div class="dash-item"><div class="val" id="dKeyframes">—</div><div class="lbl">Keyframes</div></div>
        <div class="dash-item cond"><div class="val" id="dFilename">—</div><div class="lbl">File</div></div>
      </div>
    </div>

    <!-- Playback -->
    <div class="card">
      <div class="playback">
        <button id="btnPlay" onclick="togglePlay()">&#9654; Play</button>
        <button onclick="seekDelta(-5)">-5s</button>
        <button onclick="seekDelta(5)">+5s</button>
        <span class="time-display" id="timeDisplay">0:00.0 / 0:00.0</span>
        <input type="range" class="scrubber" id="scrubber" min="0" max="1000" value="0" oninput="onScrub(this.value)">
        <select class="speed-sel" id="speedSel" onchange="setSpeed(this.value)">
          <option value="0.25">0.25x</option>
          <option value="0.5">0.5x</option>
          <option value="1" selected>1x</option>
          <option value="2">2x</option>
          <option value="4">4x</option>
        </select>
      </div>
      <div class="sound-controls">
        <button id="btnSound" onclick="toggleEngineSound()">&#128266; Engine Sound</button>
        <label>Vol <input type="range" id="sndVolume" min="0" max="100" value="40" oninput="setEngineVolume(this.value)"></label>
        <span class="rpm-readout" id="rpmReadout">— RPM</span>
      </div>
    </div>

    <!-- Filters & Indicators -->
    <div class="card">
      <div class="card-header" onclick="toggleSection('filterBody')">
        <h2>Filters &amp; Data Quality</h2>
        <span class="toggle-arrow open" id="filterBody_arrow">&#9656;</span>
      </div>
      <div class="card-body" id="filterBody">
        <div class="filter-bar" id="filterBar">
          <label><input type="checkbox" id="fltTraction" onchange="rebuildChart()" checked> Traction loss markers</label>
          <label><input type="checkbox" id="fltGpsStale" onchange="rebuildChart()"> Flag GPS stale</label>
          <label>Slip threshold: <input type="range" id="slipThreshold" min="1" max="15" value="5" style="width:80px" oninput="document.getElementById('slipThVal').textContent=this.value"><span id="slipThVal" style="color:#4fc3f7;min-width:20px">5</span> mph</label>
        </div>
        <div style="display:flex;align-items:center;gap:12px;margin-top:4px">
          <div class="traction-warn ok" id="tractionBadge">Traction OK</div>
          <span style="font-size:0.75rem;color:#666" id="tractionDetail">VSS ≈ GPS</span>
        </div>
      </div>
      <div class="card-summary hidden" id="filterBody_summary"><span class="traction-warn ok" id="tractionBadgeMini">OK</span></div>
    </div>

    <!-- Timeline Chart -->
    <div class="card">
      <div class="ch-bar" id="channelBar"></div>
      <div class="chart-wrap"><canvas id="timelineChart"></canvas></div>
    </div>

    <!-- AFR Gauge + Condition -->
    <div class="card">
      <div class="card-header" onclick="toggleSection('afrBody')">
        <h2>AFR Status</h2>
        <span class="toggle-arrow open" id="afrBody_arrow">&#9656;</span>
      </div>
      <!-- Summary shown when collapsed: compact hero bar -->
      <div class="card-summary hidden" id="afrBody_summary" style="display:none">
        <div class="afr-hero" style="margin-bottom:0">
          <div class="reading" id="afrValMini" style="font-size:1.6rem;min-width:60px">—</div>
          <div class="bar-bg" style="height:14px">
            <div class="bar-fill" id="afrBarMini"></div>
            <div class="target-zone" id="afrTargetZoneMini"></div>
          </div>
          <span id="condStatusMini" style="font-size:0.8rem;font-weight:600;min-width:60px;text-align:right">—</span>
          <span id="condBadgeMini" style="padding:2px 8px;border-radius:3px;font-size:0.7rem;font-weight:600;white-space:nowrap">—</span>
        </div>
      </div>
      <div class="card-body" id="afrBody">
        <!-- Combined: hero gauge -->
        <div class="afr-hero">
          <div class="reading" id="afrValC">—</div>
          <div class="bar-bg">
            <div class="bar-fill" id="afrBarC"></div>
            <div class="target-zone" id="afrTargetZone"></div>
          </div>
          <div class="cond-status" id="condStatus" style="min-width:70px;text-align:right"></div>
        </div>
        <!-- Banks: secondary -->
        <div class="afr-banks">
          <div><div class="label">Bank 1</div><div class="bar-bg"><div class="bar-fill" id="afrBar1"></div></div><div class="reading" id="afrVal1">—</div></div>
          <div><div class="label">Bank 2</div><div class="bar-bg"><div class="bar-fill" id="afrBar2"></div></div><div class="reading" id="afrVal2">—</div></div>
        </div>
        <div class="cond-row">
          <div class="cond-badge" id="condBadge">—</div>
          <div class="cond-target" id="condTarget">Target: —</div>
        </div>
        <div class="cond-legend" id="condLegend"></div>
      </div>
    </div>

    <!-- AFR Heatmap -->
    <div class="card">
      <div class="card-header" onclick="toggleSection('hmBody')">
        <h2>AFR Map — Est. RPM vs Load</h2>
        <span class="toggle-arrow open" id="hmBody_arrow">&#9656;</span>
      </div>
      <div class="card-summary hidden" id="hmBody_summary"><span style="font-size:0.8rem;color:#888" id="hmCurrentMini">—</span></div>
      <div class="card-body" id="hmBody">
        <div class="heatmap-wrap">
          <canvas id="afrHeatmap" height="320"></canvas>
          <div class="heatmap-info">
            <div class="heatmap-legend"><span>Rich 11</span><div class="heatmap-legend-bar" id="hmLegendBar"></div><span>15 Lean</span></div>
            <div class="heatmap-cur" id="hmCurrent">—</div>
          </div>
        </div>
      </div>
    </div>

    <!-- GPS Map -->
    <div class="card">
      <div class="card-header" onclick="toggleSection('mapBody')">
        <h2>GPS Track</h2>
        <span class="toggle-arrow open" id="mapBody_arrow">&#9656;</span>
      </div>
      <div class="card-body" id="mapBody">
        <div class="map-controls">
          <label>Color by:</label>
          <select id="mapMetric" onchange="updateMapRoute()">
            <option value="afr">AFR</option>
            <option value="speed">Speed</option>
            <option value="map">MAP Vacuum</option>
            <option value="gforce">G-Force</option>
            <option value="condition">Condition</option>
            <option value="traction">Traction (VSS-GPS)</option>
          </select>
        </div>
        <div id="mapContainer"></div>
      </div>
    </div>

    <!-- Current Values -->
    <details>
      <summary>Live Sensor Values</summary>
      <div class="panel"><div class="vals-grid" id="valsGrid"></div></div>
    </details>

    <!-- Smoothing -->
    <details>
      <summary>Smoothing &amp; Interpolation</summary>
      <div class="panel">
        <div class="smooth-row">
          <label>Moving Average:</label>
          <input type="range" id="smoothWindow" min="1" max="50" value="1" oninput="onSmoothChange()">
          <span class="val" id="smoothVal">1</span><span style="font-size:0.75rem;color:#666">pts</span>
          <label style="margin-left:16px"><input type="checkbox" id="showRaw" onchange="rebuildChart()" style="width:auto"> Show raw</label>
        </div>
      </div>
    </details>

    <!-- Condition Stats -->
    <details>
      <summary>Condition Statistics</summary>
      <div class="panel"><table id="statsTable"><thead><tr><th>Condition</th><th>Count</th><th>Time</th><th>Avg AFR</th><th>Min</th><th>Max</th><th>Target</th></tr></thead><tbody></tbody></table></div>
    </details>

    <!-- G-G Diagram -->
    <div class="card">
      <div class="card-header" onclick="toggleSection('ggBody')">
        <h2>G-G Diagram</h2>
        <span class="toggle-arrow open" id="ggBody_arrow">&#9656;</span>
      </div>
      <div class="card-summary hidden" id="ggBody_summary">
        <div style="display:flex;gap:16px;align-items:center;font-variant-numeric:tabular-nums">
          <span style="font-size:1.2rem;font-weight:700" id="ggCurMini">0.00g</span>
          <span style="font-size:0.8rem;color:#888">Max: <span id="ggMaxMini" style="color:#ef5350">0.00g</span></span>
        </div>
      </div>
      <div class="card-body" id="ggBody">
        <div style="display:flex;gap:14px;align-items:flex-start;flex-wrap:wrap">
          <div class="gg-wrap"><canvas id="ggCanvas" width="360" height="360"></canvas></div>
          <div class="gg-stats" id="ggStats" style="flex:1;min-width:140px;font-size:0.8rem"></div>
        </div>
      </div>
    </div>

    <!-- Keyframes & Export -->
    <details>
      <summary>Keyframes &amp; Export</summary>
      <div class="panel">
        <div id="keyframeList" style="margin-bottom:10px;font-size:0.8rem;color:#888">No keyframes</div>
        <button onclick="exportSegment()" style="background:#0f1a30;border:1px solid #2a4a6c;color:#ccc;padding:6px 14px;border-radius:5px;cursor:pointer;font-size:0.8rem;">Export visible segment as CSV</button>
      </div>
    </details>
  </div>
</div>

<script>
// ══════════ GLOBALS ══════════
let rows = [], smoothedRows = [], filename = '';
let playIdx = 0, playing = false, playSpeed = 1, playTimer = null;
let chart = null, leafletMap = null, routeLayer = null, condUnderlayLayer = null, keyframeMapLayer = null, playMarker = null;
const SAMPLE_MS = 80;

// ══════════ CONDITION DEFINITIONS ══════════
const CONDITIONS = {
  IDLE:       { label: 'Idle',           color: '#78909c', afr: [13.5, 14.0] },
  CRUISE_LT:  { label: 'Light Cruise',   color: '#66bb6a', afr: [14.2, 14.7] },
  CRUISE_MOD: { label: 'Mod Cruise',     color: '#26a69a', afr: [13.5, 14.0] },
  ACCEL:      { label: 'Accel / Tip-In', color: '#ffa726', afr: [12.0, 12.8] },
  WOT_LOW:    { label: 'WOT Low',        color: '#ef5350', afr: [12.5, 13.0] },
  WOT_MID:    { label: 'WOT Mid',        color: '#e53935', afr: [12.5, 12.8] },
  WOT_HIGH:   { label: 'WOT High',       color: '#b71c1c', afr: [12.2, 12.8] },
  DECEL:      { label: 'Decel / Coast',  color: '#5c6bc0', afr: [14.7, 16.0] },
  UNKNOWN:    { label: 'Unknown',        color: '#444',    afr: [12.0, 15.0] },
};

// ══════════ CHANNELS ══════════
const CHANNELS = {
  afr:     { label: 'AFR (avg)',  color: '#4fc3f7', axis: 'afr',   unit: ':1',    get: r => (r.afr + r.afr1) / 2 },
  afr1:    { label: 'AFR Bank1', color: '#29b6f6', axis: 'afr',   unit: ':1',    get: r => r.afr },
  afr2:    { label: 'AFR Bank2', color: '#81d4fa', axis: 'afr',   unit: ':1',    get: r => r.afr1 },
  speed:   { label: 'GPS Speed', color: '#66bb6a', axis: 'speed', unit: 'mph',   get: r => r.speed },
  vss:     { label: 'VSS',       color: '#a5d6a7', axis: 'speed', unit: 'mph',   get: r => r.vss },
  map:     { label: 'MAP Vac',   color: '#ffa726', axis: 'psi',   unit: 'inHg',  get: r => r.map },
  oilp:    { label: 'Oil Press', color: '#ff7043', axis: 'psi',   unit: 'psi',   get: r => r.oilp },
  coolant: { label: 'Coolant',   color: '#ef5350', axis: 'temp',  unit: '°F',    get: r => r.coolant },
  accx:    { label: 'Accel X',   color: '#ab47bc', axis: 'g',     unit: 'g',     get: r => r.accx },
  accy:    { label: 'Accel Y',   color: '#7e57c2', axis: 'g',     unit: 'g',     get: r => r.accy },
  gforce:  { label: 'G-Force',   color: '#ce93d8', axis: 'g',     unit: 'g',     get: r => Math.sqrt(r.accx**2 + r.accy**2) },
  alt:     { label: 'Altitude',  color: '#8d6e63', axis: 'alt',   unit: 'ft',    get: r => r.alt },
};
const defaultChannels = ['afr', 'speed', 'map'];
let activeChannels = new Set(defaultChannels);

// ══════════ SECTION COLLAPSE ══════════
function toggleSection(id) {
  const body = document.getElementById(id);
  const arrow = document.getElementById(id + '_arrow');
  const summary = document.getElementById(id + '_summary');
  if (!body) return;
  const collapsed = body.classList.toggle('collapsed');
  if (arrow) arrow.classList.toggle('open', !collapsed);
  if (summary) summary.classList.toggle('hidden', !collapsed);
  // Redraw heatmap/map/gg after expand
  if (!collapsed) {
    if (id === 'hmBody') setTimeout(() => drawHeatmap(), 50);
    if (id === 'mapBody' && leafletMap) setTimeout(() => leafletMap.invalidateSize(), 50);
    if (id === 'ggBody') setTimeout(() => drawGG(), 50);
  }
}

// ══════════ TRACTION DETECTION ══════════
const SLIP_THRESHOLD_DEFAULT = 5; // mph

function getSlipThreshold() {
  return parseInt(document.getElementById('slipThreshold')?.value || SLIP_THRESHOLD_DEFAULT);
}

function detectSlip(r) {
  const vss = r.vss, gps = r.speed;
  if (gps < 3 && vss < 3) return { slip: false, delta: 0 }; // ignore at near-stop
  const delta = vss - gps;
  return { slip: Math.abs(delta) > getSlipThreshold(), delta };
}

// ══════════ UPLOAD ══════════
const uploadZone = document.getElementById('uploadZone');
const fileInput = document.getElementById('fileInput');
uploadZone.addEventListener('click', () => fileInput.click());
uploadZone.addEventListener('dragover', e => { e.preventDefault(); uploadZone.classList.add('dragover'); });
uploadZone.addEventListener('dragleave', () => uploadZone.classList.remove('dragover'));
uploadZone.addEventListener('drop', e => { e.preventDefault(); uploadZone.classList.remove('dragover'); if (e.dataTransfer.files.length) loadFile(e.dataTransfer.files[0]); });
fileInput.addEventListener('change', () => { if (fileInput.files.length) loadFile(fileInput.files[0]); });

function loadFile(file) {
  filename = file.name;
  const reader = new FileReader();
  reader.onload = e => {
    parseCSV(e.target.result);
    if (rows.length > 0) initUI();
  };
  reader.readAsText(file);
}

// ══════════ CSV PARSER ══════════
const EXPECTED_COLS = ['time','lat','lon','speed','alt','dir','sats','accx','accy','accz','rotx','roty','rotz','magx','magy','magz','imutemp','afr','afr1','vss','map','oilp','coolant','gpsstale','keyframe'];

function parseCSV(text) {
  const lines = text.trim().split('\n');
  if (lines.length < 3) { alert('CSV too short'); return; }

  // Find header line (skip date line if present)
  let headerIdx = 0;
  if (!lines[0].includes('time')) headerIdx = 1;
  const header = lines[headerIdx].split(',').map(h => h.trim().toLowerCase());

  // Build column index map
  const colMap = {};
  header.forEach((h, i) => colMap[h] = i);

  // Skip units row
  const dataStart = headerIdx + 2;
  rows = [];
  for (let i = dataStart; i < lines.length; i++) {
    const line = lines[i].trim();
    if (!line) continue;
    const c = line.split(',');
    if (c.length < 20) continue;

    const get = (name, def = 0) => {
      const idx = colMap[name];
      return idx !== undefined ? (parseFloat(c[idx]) || def) : def;
    };

    const lat = get('lat');
    const lon = get('lon');

    rows.push({
      idx: rows.length,
      time: get('time'),
      lat: Math.abs(lat) > 360 ? lat / 1e7 : lat,
      lon: Math.abs(lon) > 360 ? lon / 1e7 : lon,
      speed: get('speed'),
      alt: get('alt'),
      dir: get('dir'),
      sats: get('sats'),
      accx: get('accx'), accy: get('accy'), accz: get('accz'),
      rotx: get('rotx'), roty: get('roty'), rotz: get('rotz'),
      magx: get('magx'), magy: get('magy'), magz: get('magz'),
      imuTemp: get('imutemp'),
      afr: get('afr'), afr1: get('afr1'),
      vss: get('vss'), map: get('map'),
      oilp: get('oilp'), coolant: get('coolant'),
      gpsStale: get('gpsstale') > 0,
      keyframe: get('keyframe'),
      condition: 'UNKNOWN',
    });
  }

  // Detect conditions
  detectAllConditions();
  applySmoothing();
}

// ══════════ CONDITION DETECTION ══════════
let prevCondition = 'UNKNOWN', condHoldUntil = 0;
const HYSTERESIS_ROWS = Math.round(500 / SAMPLE_MS); // 0.5s

function detectCondition(r, prevR) {
  const { vss, map: mapVac, accx } = r;
  const speed = vss > 0 ? vss : r.speed;

  // WOT: very low vacuum
  if (mapVac < 3) {
    if (speed < 40) return 'WOT_LOW';
    if (speed < 60) return 'WOT_MID';
    return 'WOT_HIGH';
  }

  // Decel: high vacuum + moving
  if (mapVac > 18 && speed > 5) return 'DECEL';

  // Accel: rapid MAP drop (vacuum decrease = throttle opening)
  if (prevR) {
    const mapDelta = prevR.map - mapVac;
    if (mapDelta > 3) return 'ACCEL';
  }

  // Idle: slow + high vacuum
  if (speed < 5 && mapVac > 12) return 'IDLE';

  // Cruise: moderate vacuum
  if (mapVac > 12) return 'CRUISE_LT';
  if (mapVac >= 5) return 'CRUISE_MOD';

  return 'UNKNOWN';
}

function detectAllConditions() {
  prevCondition = 'UNKNOWN';
  condHoldUntil = 0;
  for (let i = 0; i < rows.length; i++) {
    const raw = detectCondition(rows[i], i > 0 ? rows[i-1] : null);
    if (raw !== prevCondition && i >= condHoldUntil) {
      prevCondition = raw;
      condHoldUntil = i + HYSTERESIS_ROWS;
    }
    rows[i].condition = prevCondition;
  }
}

// ══════════ SMOOTHING ══════════
function applySmoothing() {
  const win = parseInt(document.getElementById('smoothWindow')?.value || '1');
  if (win <= 1) { smoothedRows = rows; return; }
  const fields = ['afr','afr1','vss','speed','map','oilp','coolant','accx','accy','accz','rotx','roty','rotz'];
  smoothedRows = rows.map((r, i) => {
    const out = { ...r };
    const lo = Math.max(0, i - Math.floor(win/2));
    const hi = Math.min(rows.length - 1, i + Math.floor(win/2));
    const n = hi - lo + 1;
    fields.forEach(f => {
      let sum = 0;
      for (let j = lo; j <= hi; j++) sum += rows[j][f];
      out[f] = sum / n;
    });
    return out;
  });
}

function onSmoothChange() {
  document.getElementById('smoothVal').textContent = document.getElementById('smoothWindow').value;
  applySmoothing();
  rebuildChart();
  updatePlaybackUI();
}

// ══════════ INIT UI ══════════
function initUI() {
  document.getElementById('uploadCard').classList.add('hidden');
  document.getElementById('mainUI').classList.remove('hidden');

  const dur = rows[rows.length-1].time;
  document.getElementById('dDuration').textContent = fmtTime(dur);
  document.getElementById('dRows').textContent = rows.length.toLocaleString();
  document.getElementById('dKeyframes').textContent = rows.filter(r => r.keyframe > 0).length;
  document.getElementById('dFilename').textContent = filename;

  document.getElementById('scrubber').max = rows.length - 1;
  buildChannelBar();
  buildCondLegend();
  buildChart();
  initMap();
  buildKeyframeList();
  buildStatsTable();
  drawGG();
  resetHeatmapData();
  populateHeatmapUpTo(0);
  drawHeatmap();
  updatePlaybackUI();
}

// ══════════ CHANNEL BAR ══════════
function buildChannelBar() {
  const bar = document.getElementById('channelBar');
  bar.innerHTML = '';
  Object.entries(CHANNELS).forEach(([key, ch]) => {
    const lbl = document.createElement('label');
    lbl.innerHTML = `<input type="checkbox" ${activeChannels.has(key) ? 'checked' : ''} data-ch="${key}"><span style="color:${ch.color}">${ch.label}</span>`;
    lbl.querySelector('input').addEventListener('change', e => {
      if (e.target.checked) activeChannels.add(key); else activeChannels.delete(key);
      rebuildChart();
    });
    bar.appendChild(lbl);
  });
}

// ══════════ CONDITION LEGEND ══════════
function buildCondLegend() {
  const el = document.getElementById('condLegend');
  el.innerHTML = '';
  Object.entries(CONDITIONS).forEach(([k, c]) => {
    if (k === 'UNKNOWN') return;
    const item = document.createElement('span');
    item.className = 'cond-legend-item';
    item.innerHTML = `<span class="cond-dot" style="background:${c.color}"></span>${c.label}`;
    el.appendChild(item);
  });
}

// ══════════ CHART ══════════
function buildChart() {
  const ctx = document.getElementById('timelineChart').getContext('2d');

  // Condition background plugin
  const condBgPlugin = {
    id: 'condBg',
    beforeDraw(chart) {
      const { ctx, chartArea: { left, right, top, bottom }, scales: { x } } = chart;
      if (!x || !smoothedRows.length) return;
      ctx.save();
      let prevCond = null, startX = left;
      const dataRows = smoothedRows;
      for (let i = 0; i < dataRows.length; i++) {
        const cond = dataRows[i].condition;
        const px = x.getPixelForValue(i);
        if (cond !== prevCond && prevCond !== null) {
          ctx.fillStyle = (CONDITIONS[prevCond]?.color || '#444') + '18';
          ctx.fillRect(startX, top, px - startX, bottom - top);
          startX = px;
        }
        prevCond = cond;
      }
      if (prevCond) {
        ctx.fillStyle = (CONDITIONS[prevCond]?.color || '#444') + '18';
        ctx.fillRect(startX, top, right - startX, bottom - top);
      }
      ctx.restore();
    }
  };

  // Playback cursor plugin
  const cursorPlugin = {
    id: 'cursor',
    afterDraw(chart) {
      const { ctx, chartArea: { top, bottom }, scales: { x } } = chart;
      if (!x) return;
      const px = x.getPixelForValue(playIdx);
      ctx.save();
      ctx.strokeStyle = '#ffffff88';
      ctx.lineWidth = 1;
      ctx.setLineDash([4, 3]);
      ctx.beginPath(); ctx.moveTo(px, top); ctx.lineTo(px, bottom); ctx.stroke();
      ctx.restore();
    }
  };

  // Keyframe markers plugin
  const keyframePlugin = {
    id: 'keyframes',
    afterDraw(chart) {
      const { ctx, chartArea: { top, bottom }, scales: { x } } = chart;
      if (!x) return;
      ctx.save();
      rows.forEach(r => {
        if (r.keyframe <= 0) return;
        const px = x.getPixelForValue(r.idx);
        // Vertical line
        ctx.strokeStyle = '#ffd54f';
        ctx.lineWidth = 1.5;
        ctx.setLineDash([]);
        ctx.beginPath(); ctx.moveTo(px, top); ctx.lineTo(px, bottom); ctx.stroke();
        // Number label
        ctx.fillStyle = '#1a1a2e';
        ctx.strokeStyle = '#ffd54f';
        ctx.lineWidth = 1;
        const w = 18, h = 14;
        const bx = px - w/2, by = top - h - 2;
        ctx.beginPath();
        if (ctx.roundRect) { ctx.roundRect(bx, by, w, h, 3); }
        else { ctx.moveTo(bx+3,by); ctx.lineTo(bx+w-3,by); ctx.arcTo(bx+w,by,bx+w,by+3,3); ctx.lineTo(bx+w,by+h-3); ctx.arcTo(bx+w,by+h,bx+w-3,by+h,3); ctx.lineTo(bx+3,by+h); ctx.arcTo(bx,by+h,bx,by+h-3,3); ctx.lineTo(bx,by+3); ctx.arcTo(bx,by,bx+3,by,3); ctx.closePath(); }
        ctx.fill(); ctx.stroke();
        ctx.fillStyle = '#ffd54f';
        ctx.font = 'bold 9px sans-serif';
        ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
        ctx.fillText('#' + r.keyframe, px, by + h/2);
      });
      ctx.restore();
    }
  };

  // Traction loss overlay plugin — red markers at top of chart where VSS-GPS diverges
  const tractionPlugin = {
    id: 'traction',
    afterDraw(chart) {
      if (!document.getElementById('fltTraction')?.checked) return;
      const { ctx, chartArea: { left, right, top }, scales: { x } } = chart;
      if (!x) return;
      const th = getSlipThreshold();
      ctx.save();
      for (let i = 0; i < rows.length; i++) {
        const r = rows[i];
        const delta = r.vss - r.speed;
        if (r.speed < 3 && r.vss < 3) continue;
        if (Math.abs(delta) > th) {
          const px = x.getPixelForValue(i);
          ctx.fillStyle = delta > 0 ? 'rgba(255,82,82,0.6)' : 'rgba(255,152,0,0.6)';
          ctx.fillRect(px, top, 2, 6);
        }
      }
      ctx.restore();
    }
  };

  chart = new Chart(ctx, {
    type: 'line',
    data: { datasets: [] },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      animation: false,
      parsing: false,
      elements: { point: { radius: 0 }, line: { borderWidth: 1.5 } },
      interaction: { mode: 'index', intersect: false },
      plugins: { legend: { display: false }, tooltip: { enabled: false } },
      scales: {
        x: { type: 'linear', display: true, ticks: { callback: v => fmtTime(smoothedRows[Math.round(v)]?.time || 0), color: '#666', maxTicksLimit: 10 }, grid: { color: '#1a3a5c33' } },
      },
    },
    plugins: [condBgPlugin, cursorPlugin, keyframePlugin, tractionPlugin],
  });
  rebuildChart();
}

function rebuildChart() {
  if (!chart || !smoothedRows.length) return;
  const data = smoothedRows;
  const showRaw = document.getElementById('showRaw')?.checked;

  // Build y-axis configs
  const axisMap = {};
  const datasets = [];

  activeChannels.forEach(key => {
    const ch = CHANNELS[key];
    if (!ch) return;
    if (!axisMap[ch.axis]) {
      axisMap[ch.axis] = {
        type: 'linear',
        position: Object.keys(axisMap).length % 2 === 0 ? 'left' : 'right',
        ticks: { color: ch.color + '99', maxTicksLimit: 6 },
        grid: { drawOnChartArea: Object.keys(axisMap).length === 0, color: '#1a3a5c22' },
      };
    }

    datasets.push({
      label: ch.label,
      data: data.map((r, i) => ({ x: i, y: ch.get(r) })),
      borderColor: ch.color,
      backgroundColor: ch.color + '11',
      yAxisID: ch.axis,
      tension: 0.2,
    });

    // Raw overlay
    if (showRaw && smoothedRows !== rows) {
      datasets.push({
        label: ch.label + ' (raw)',
        data: rows.map((r, i) => ({ x: i, y: ch.get(r) })),
        borderColor: ch.color + '33',
        borderDash: [2, 2],
        yAxisID: ch.axis,
        tension: 0,
        borderWidth: 1,
      });
    }
  });

  chart.data.datasets = datasets;
  chart.options.scales = { x: chart.options.scales.x };
  Object.entries(axisMap).forEach(([id, cfg]) => chart.options.scales[id] = cfg);
  chart.update('none');
}

// ══════════ MAP ══════════
function initMap() {
  const gpsRows = rows.filter(r => r.lat !== 0 && r.lon !== 0 && !r.gpsStale);
  if (gpsRows.length === 0) {
    document.getElementById('mapContainer').innerHTML = '<p style="padding:40px;text-align:center;color:#666">No GPS data</p>';
    return;
  }

  leafletMap = L.map('mapContainer', { zoomControl: true }).setView([gpsRows[0].lat, gpsRows[0].lon], 14);
  L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png', {
    attribution: '&copy; OpenStreetMap',
    maxZoom: 19,
  }).addTo(leafletMap);

  playMarker = L.circleMarker([gpsRows[0].lat, gpsRows[0].lon], { radius: 7, color: '#fff', fillColor: '#4fc3f7', fillOpacity: 1, weight: 2 }).addTo(leafletMap);

  updateMapRoute();
  addKeyframeMarkers();

  // Fit bounds
  const bounds = L.latLngBounds(gpsRows.map(r => [r.lat, r.lon]));
  leafletMap.fitBounds(bounds, { padding: [30, 30] });
}

function updateMapRoute() {
  if (!leafletMap) return;
  if (condUnderlayLayer) leafletMap.removeLayer(condUnderlayLayer);
  if (routeLayer) leafletMap.removeLayer(routeLayer);

  const metric = document.getElementById('mapMetric').value;
  const gpsRows = rows.filter(r => r.lat !== 0 && r.lon !== 0 && !r.gpsStale);
  if (gpsRows.length < 2) return;

  // Condition underlay — wider line underneath showing condition color with alternating brightness
  condUnderlayLayer = L.layerGroup();
  let prevCond = null, segStart = 0, condIdx = 0;
  for (let i = 1; i <= gpsRows.length; i++) {
    const cond = i < gpsRows.length ? gpsRows[i].condition : null;
    if (cond !== prevCond || i === gpsRows.length) {
      if (prevCond !== null && i - segStart > 1) {
        const pts = [];
        for (let j = segStart; j < i; j++) pts.push([gpsRows[j].lat, gpsRows[j].lon]);
        const condColor = CONDITIONS[prevCond]?.color || '#444';
        // Alternate brightness: even segments get base color, odd get lighter tint
        const opacity = condIdx % 2 === 0 ? 0.5 : 0.35;
        L.polyline(pts, { color: condColor, weight: 9, opacity, lineCap: 'round', lineJoin: 'round' }).addTo(condUnderlayLayer);
        condIdx++;
      }
      prevCond = cond;
      segStart = i;
    }
  }
  condUnderlayLayer.addTo(leafletMap);

  // Metric-colored route on top (thinner)
  routeLayer = L.layerGroup();
  for (let i = 1; i < gpsRows.length; i++) {
    const r = gpsRows[i];
    const color = metricColor(r, metric);
    L.polyline([[gpsRows[i-1].lat, gpsRows[i-1].lon], [r.lat, r.lon]], { color, weight: 3, opacity: 0.9 }).addTo(routeLayer);
  }
  routeLayer.addTo(leafletMap);
}

function addKeyframeMarkers() {
  if (!leafletMap) return;
  if (keyframeMapLayer) leafletMap.removeLayer(keyframeMapLayer);
  keyframeMapLayer = L.layerGroup();

  const kfRows = rows.filter(r => r.keyframe > 0 && r.lat !== 0 && r.lon !== 0 && !r.gpsStale);
  kfRows.forEach(r => {
    const icon = L.divIcon({
      className: '',
      html: `<div style="background:#ffd54f;color:#1a1a2e;font-weight:700;font-size:11px;width:22px;height:22px;border-radius:50%;display:flex;align-items:center;justify-content:center;border:2px solid #1a1a2e;box-shadow:0 1px 4px rgba(0,0,0,0.6)">#${r.keyframe}</div>`,
      iconSize: [22, 22],
      iconAnchor: [11, 11],
    });
    const marker = L.marker([r.lat, r.lon], { icon }).addTo(keyframeMapLayer);
    marker.bindTooltip(`KF #${r.keyframe} @ ${fmtTime(r.time)}`, { direction: 'top', offset: [0, -14] });
    marker.on('click', () => { playIdx = r.idx; updatePlaybackUI(); });
  });
  keyframeMapLayer.addTo(leafletMap);
}

function metricColor(r, metric) {
  switch (metric) {
    case 'afr': return afrToColor((r.afr + r.afr1) / 2);
    case 'speed': return valToColor(r.vss || r.speed, 0, 100, '#66bb6a', '#ef5350');
    case 'map': return valToColor(r.map, 0, 20, '#ef5350', '#66bb6a');
    case 'gforce': return valToColor(Math.sqrt(r.accx**2 + r.accy**2), 0, 1.5, '#66bb6a', '#ef5350');
    case 'condition': return CONDITIONS[r.condition]?.color || '#444';
    case 'traction': {
      const delta = Math.abs(r.vss - r.speed);
      if (delta > getSlipThreshold()) return '#ff5252';
      if (delta > getSlipThreshold() * 0.6) return '#ffa726';
      return '#66bb6a';
    }
    default: return '#4fc3f7';
  }
}

function afrToColor(afr) {
  if (afr < 11.5) return '#b71c1c';
  if (afr < 12.5) return '#ff5722';
  if (afr < 13.0) return '#ff9800';
  if (afr < 13.8) return '#ffc107';
  if (afr < 14.5) return '#8bc34a';
  return '#4caf50';
}

// ══════════ RPM ESTIMATION ══════════
// TH400 3-speed auto: 1st=2.48, 2nd=1.48, 3rd=1.00, final=3.73
// Tire: 235/70R15, circumference=2.23m=7.316ft
const GEARS = [2.48, 1.48, 1.00];
const FINAL_DRIVE = 3.73;
const TIRE_CIRC_FT = 7.316;

function estimateRPM(speedMph) {
  if (speedMph < 2) return 700; // idle
  const fpm = speedMph * 88; // feet per minute
  // Auto-detect gear from speed
  let gear;
  if (speedMph < 18) gear = GEARS[0];      // 1st
  else if (speedMph < 40) gear = GEARS[1];  // 2nd
  else gear = GEARS[2];                      // 3rd
  return (fpm * FINAL_DRIVE * gear) / TIRE_CIRC_FT;
}

// ══════════ AFR HEATMAP ══════════
// Grid: RPM (X) 500-6500 in 500 steps = 13 cols, MAP/Load (Y) 0-22 inHg in 2 steps = 12 rows
const HM_RPM_MIN = 500, HM_RPM_MAX = 6500, HM_RPM_STEP = 500;
const HM_MAP_MIN = 0, HM_MAP_MAX = 22, HM_MAP_STEP = 2;
const HM_COLS = Math.floor((HM_RPM_MAX - HM_RPM_MIN) / HM_RPM_STEP) + 1; // 13
const HM_ROWS = Math.floor((HM_MAP_MAX - HM_MAP_MIN) / HM_MAP_STEP) + 1; // 12
let hmData = []; // [row][col] = { sum, count }
let hmTrail = []; // ghost trail: last N positions as {col, row, afr}
const TRAIL_LEN = 30; // ~2.4s at 12.5Hz

let hmPopulatedTo = -1; // track incremental population

function resetHeatmapData() {
  hmData = [];
  for (let r = 0; r < HM_ROWS; r++) {
    hmData[r] = [];
    for (let c = 0; c < HM_COLS; c++) hmData[r][c] = { sum: 0, count: 0 };
  }
  hmTrail = [];
  hmPopulatedTo = -1;
}

function hmColFromRPM(rpm) { return Math.max(0, Math.min(HM_COLS - 1, Math.round((rpm - HM_RPM_MIN) / HM_RPM_STEP))); }
function hmRowFromMAP(mapV) { return Math.max(0, Math.min(HM_ROWS - 1, HM_ROWS - 1 - Math.round((mapV - HM_MAP_MIN) / HM_MAP_STEP))); }

function addRowToHeatmap(r) {
  const rpm = estimateRPM(r.vss || r.speed);
  const col = hmColFromRPM(rpm);
  const row = hmRowFromMAP(r.map);
  const afr = (r.afr + r.afr1) / 2;
  if (afr > 8 && afr < 20) {
    hmData[row][col].sum += afr;
    hmData[row][col].count++;
  }
}

function populateHeatmapUpTo(idx) {
  idx = Math.min(idx, rows.length - 1);
  // If scrubbed backwards, rebuild from scratch
  if (idx < hmPopulatedTo) {
    resetHeatmapData();
  }
  // Incrementally add new rows
  const start = hmPopulatedTo + 1;
  for (let i = start; i <= idx; i++) addRowToHeatmap(rows[i]);
  hmPopulatedTo = idx;

  // Build trail from last TRAIL_LEN rows
  hmTrail = [];
  const trailStart = Math.max(0, idx - TRAIL_LEN);
  for (let i = trailStart; i <= idx; i++) {
    const r = rows[i];
    const rpm = estimateRPM(r.vss || r.speed);
    hmTrail.push({ col: hmColFromRPM(rpm), row: hmRowFromMAP(r.map), afr: (r.afr + r.afr1) / 2 });
  }
}

function afrColorRGB(afr) {
  const t = Math.max(0, Math.min(1, (afr - 11.0) / (15.0 - 11.0)));
  let rv, g, b;
  if (t < 0.35) { const s = t/0.35; rv=255; g=70+s*100; b=30+s*30; }
  else if (t < 0.65) { const s=(t-0.35)/0.3; rv=255-s*120; g=170+s*60; b=60+s*40; }
  else { const s=(t-0.65)/0.35; rv=135-s*70; g=230-s*40; b=100+s*60; }
  return `rgb(${Math.round(rv)},${Math.round(g)},${Math.round(b)})`;
}

function drawHeatmap() {
  const canvas = document.getElementById('afrHeatmap');
  if (!canvas) return;
  const dpr = window.devicePixelRatio || 1;
  const rect = canvas.getBoundingClientRect();
  const W = rect.width, H = 320;
  canvas.width = W * dpr; canvas.height = H * dpr;
  canvas.style.height = H + 'px';
  const ctx = canvas.getContext('2d');
  ctx.scale(dpr, dpr);

  const left = 50, top = 14, right = 12, bottom = 34;
  const gw = W - left - right, gh = H - top - bottom;
  const cw = gw / HM_COLS, ch = gh / HM_ROWS;

  ctx.clearRect(0, 0, W, H);

  // Draw cells
  for (let r = 0; r < HM_ROWS; r++) {
    for (let c = 0; c < HM_COLS; c++) {
      const x = left + c * cw, y = top + r * ch;
      const d = hmData[r][c];
      if (d.count === 0) {
        ctx.fillStyle = '#0a0f1e';
        ctx.fillRect(x + 0.5, y + 0.5, cw - 1, ch - 1);
      } else {
        const avg = d.sum / d.count;
        ctx.fillStyle = afrColorRGB(avg);
        ctx.globalAlpha = Math.min(1, 0.3 + d.count * 0.05);
        ctx.fillRect(x + 0.5, y + 0.5, cw - 1, ch - 1);
        ctx.globalAlpha = 1;
        // Value text if cell is wide enough
        if (cw > 38) {
          ctx.fillStyle = '#000';
          ctx.font = `bold ${cw > 48 ? 11 : 9}px sans-serif`;
          ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
          ctx.fillText(avg.toFixed(1), x + cw/2, y + ch/2 - (ch > 24 ? 4 : 0));
          // Sample count below AFR value
          if (ch > 24) {
            ctx.fillStyle = 'rgba(0,0,0,0.5)';
            ctx.font = `${cw > 48 ? 8 : 7}px sans-serif`;
            ctx.fillText('n=' + d.count, x + cw/2, y + ch/2 + 8);
          }
        }
      }
    }
  }

  // Ghost trail
  for (let i = 0; i < hmTrail.length; i++) {
    const t = hmTrail[i];
    const age = hmTrail.length - 1 - i; // 0 = newest
    const alpha = Math.max(0.05, 1 - age / TRAIL_LEN);
    const x = left + t.col * cw + cw/2;
    const y = top + t.row * ch + ch/2;
    ctx.beginPath();
    ctx.arc(x, y, 3 + (1 - age/TRAIL_LEN) * 2, 0, Math.PI * 2);
    ctx.fillStyle = `rgba(255,255,255,${alpha * 0.4})`;
    ctx.fill();
  }

  // Trail line connecting dots
  if (hmTrail.length > 1) {
    ctx.beginPath();
    ctx.strokeStyle = 'rgba(79,195,247,0.35)';
    ctx.lineWidth = 1.5;
    hmTrail.forEach((t, i) => {
      const x = left + t.col * cw + cw/2;
      const y = top + t.row * ch + ch/2;
      if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
    });
    ctx.stroke();
  }

  // Current position dot (big bright)
  if (hmTrail.length > 0) {
    const cur = hmTrail[hmTrail.length - 1];
    const cx = left + cur.col * cw + cw/2;
    const cy = top + cur.row * ch + ch/2;
    // Glow
    ctx.beginPath(); ctx.arc(cx, cy, 10, 0, Math.PI*2);
    ctx.fillStyle = 'rgba(79,195,247,0.2)'; ctx.fill();
    // Dot
    ctx.beginPath(); ctx.arc(cx, cy, 5, 0, Math.PI*2);
    ctx.fillStyle = '#fff'; ctx.fill();
    ctx.strokeStyle = '#4fc3f7'; ctx.lineWidth = 2; ctx.stroke();
  }

  // Y-axis labels (MAP vacuum — bottom=0/WOT, top=22/idle)
  ctx.fillStyle = '#888'; ctx.font = '10px sans-serif';
  ctx.textAlign = 'right'; ctx.textBaseline = 'middle';
  for (let r = 0; r < HM_ROWS; r++) {
    const mapVal = HM_MAP_MAX - r * HM_MAP_STEP;
    if (r % 2 === 0) ctx.fillText(mapVal + '"', left - 4, top + r * ch + ch/2);
  }

  // X-axis labels (RPM)
  ctx.textAlign = 'center'; ctx.textBaseline = 'top';
  for (let c = 0; c < HM_COLS; c++) {
    const rpm = HM_RPM_MIN + c * HM_RPM_STEP;
    if (c % 2 === 0) ctx.fillText(rpm, left + c * cw + cw/2, top + gh + 4);
  }

  // Axis titles
  ctx.fillStyle = '#4fc3f7'; ctx.font = '11px sans-serif'; ctx.textAlign = 'center';
  ctx.fillText('Est. RPM (from VSS + gear)', left + gw/2, H - 2);
  ctx.save(); ctx.translate(10, top + gh/2); ctx.rotate(-Math.PI/2);
  ctx.fillText('MAP Vacuum (inHg)', 0, 0); ctx.restore();

  // Legend bar
  const bar = document.getElementById('hmLegendBar');
  if (bar) bar.style.background = 'linear-gradient(to right, rgb(255,70,30), rgb(255,170,60), rgb(135,230,100), rgb(65,190,160))';

  // Current readout
  if (rows.length > 0 && playIdx < rows.length) {
    const r = rows[playIdx];
    const rpm = estimateRPM(r.vss || r.speed);
    const afr = ((r.afr + r.afr1) / 2).toFixed(2);
    document.getElementById('hmCurrent').textContent = `RPM ≈${Math.round(rpm)} | MAP ${r.map.toFixed(1)}" | AFR ${afr}`;
  }
}

function valToColor(val, min, max, colLow, colHigh) {
  const t = Math.max(0, Math.min(1, (val - min) / (max - min)));
  return t < 0.5 ? colLow : colHigh;
}

// ══════════ PLAYBACK ══════════
function togglePlay() {
  if (playing) pause(); else play();
}

function play() {
  playing = true;
  document.getElementById('btnPlay').textContent = '\u23F8 Pause';
  document.getElementById('btnPlay').classList.add('active');
  const interval = SAMPLE_MS / playSpeed;
  playTimer = setInterval(() => {
    playIdx++;
    if (playIdx >= rows.length) { playIdx = rows.length - 1; pause(); return; }
    updatePlaybackUI();
  }, interval);
}

function pause() {
  playing = false;
  clearInterval(playTimer);
  document.getElementById('btnPlay').textContent = '\u25B6 Play';
  document.getElementById('btnPlay').classList.remove('active');
}

function seekDelta(sec) {
  const delta = Math.round(sec * 1000 / SAMPLE_MS);
  playIdx = Math.max(0, Math.min(rows.length - 1, playIdx + delta));
  updatePlaybackUI();
}

function onScrub(val) {
  playIdx = parseInt(val);
  updatePlaybackUI();
}

function setSpeed(val) { playSpeed = parseFloat(val); if (playing) { pause(); play(); } }

function updatePlaybackUI() {
  if (!rows.length) return;
  const r = smoothedRows[playIdx] || rows[playIdx];
  const raw = rows[playIdx];
  const total = rows[rows.length-1].time;

  // Time display
  document.getElementById('timeDisplay').textContent = `${fmtTime(raw.time)} / ${fmtTime(total)}`;
  document.getElementById('scrubber').value = playIdx;

  // AFR gauges
  const afr1 = r.afr, afr2 = r.afr1, afrC = (afr1 + afr2) / 2;
  const cond = CONDITIONS[raw.condition] || CONDITIONS.UNKNOWN;

  // Combined hero gauge
  updateAfrBar('afrBarC', 'afrValC', afrC);
  // Bank gauges (secondary)
  updateAfrBar('afrBar1', 'afrVal1', afr1);
  updateAfrBar('afrBar2', 'afrVal2', afr2);

  // Target zone overlay on combined gauge bar
  const tgtZone = document.getElementById('afrTargetZone');
  if (tgtZone) {
    const lo = Math.max(0, ((cond.afr[0] - 10) / 6) * 100);
    const hi = Math.min(100, ((cond.afr[1] - 10) / 6) * 100);
    tgtZone.style.left = lo + '%';
    tgtZone.style.width = (hi - lo) + '%';
  }

  // Condition badge
  const badge = document.getElementById('condBadge');
  badge.textContent = cond.label;
  badge.style.background = cond.color;
  badge.style.color = '#fff';
  document.getElementById('condTarget').textContent = `Target: ${cond.afr[0].toFixed(1)}–${cond.afr[1].toFixed(1)}`;

  // Status text
  let statusText, statusColor;
  if (afrC < cond.afr[0] - 0.5) { statusText = 'LEAN!'; statusColor = '#ef5350'; }
  else if (afrC < cond.afr[0]) { statusText = 'Lean'; statusColor = '#ffa726'; }
  else if (afrC <= cond.afr[1]) { statusText = 'On Target'; statusColor = '#66bb6a'; }
  else if (afrC <= cond.afr[1] + 0.5) { statusText = 'Rich'; statusColor = '#ffa726'; }
  else { statusText = 'RICH!'; statusColor = '#ff7043'; }

  const statusEl = document.getElementById('condStatus');
  statusEl.textContent = statusText;
  statusEl.style.color = statusColor;

  // Mini summary for collapsed view (animated bar)
  const miniVal = document.getElementById('afrValMini');
  const miniStatus = document.getElementById('condStatusMini');
  const miniBadge = document.getElementById('condBadgeMini');
  if (miniVal) { miniVal.textContent = afrC.toFixed(2); miniVal.style.color = afrToColor(afrC); }
  if (miniStatus) { miniStatus.textContent = statusText; miniStatus.style.color = statusColor; }
  if (miniBadge) { miniBadge.textContent = cond.label; miniBadge.style.background = cond.color; miniBadge.style.color = '#fff'; }
  updateAfrBar('afrBarMini', null, afrC);
  const tgtMini = document.getElementById('afrTargetZoneMini');
  if (tgtMini) {
    const lo2 = Math.max(0, ((cond.afr[0] - 10) / 6) * 100);
    const hi2 = Math.min(100, ((cond.afr[1] - 10) / 6) * 100);
    tgtMini.style.left = lo2 + '%'; tgtMini.style.width = (hi2 - lo2) + '%';
  }

  // Traction detection
  const { slip, delta } = detectSlip(raw);
  const tBadge = document.getElementById('tractionBadge');
  const tDetail = document.getElementById('tractionDetail');
  const tMini = document.getElementById('tractionBadgeMini');
  if (slip) {
    const dir = delta > 0 ? 'wheelspin' : 'lockup';
    tBadge.className = 'traction-warn slip';
    tBadge.textContent = `SLIP — ${dir}`;
    tDetail.textContent = `VSS ${raw.vss.toFixed(1)} vs GPS ${raw.speed.toFixed(1)} (Δ${delta.toFixed(1)} mph)`;
    if (tMini) { tMini.className = 'traction-warn slip'; tMini.textContent = `SLIP Δ${Math.abs(delta).toFixed(0)}`; }
  } else {
    tBadge.className = 'traction-warn ok';
    tBadge.textContent = 'Traction OK';
    tDetail.textContent = `VSS ${raw.vss.toFixed(1)} ≈ GPS ${raw.speed.toFixed(1)}`;
    if (tMini) { tMini.className = 'traction-warn ok'; tMini.textContent = 'OK'; }
  }

  // Map marker
  if (playMarker && raw.lat && raw.lon) playMarker.setLatLng([raw.lat, raw.lon]);

  // Chart cursor
  if (chart) chart.update('none');

  // Heatmap (skip if collapsed)
  if (!document.getElementById('hmBody')?.classList.contains('collapsed')) {
    populateHeatmapUpTo(playIdx);
    drawHeatmap();
  } else {
    // Still populate data even when collapsed, just skip drawing
    populateHeatmapUpTo(playIdx);
    const hmMini = document.getElementById('hmCurrentMini');
    if (hmMini && raw) {
      const rpm = estimateRPM(raw.vss || raw.speed);
      hmMini.textContent = `RPM ≈${Math.round(rpm)} | MAP ${raw.map.toFixed(1)}" | AFR ${afrC.toFixed(2)}`;
    }
  }

  // G-G diagram (live)
  const ggCollapsed = document.getElementById('ggBody')?.classList.contains('collapsed');
  if (!ggCollapsed) drawGG();
  updateGGStats(raw);

  // Engine sound — update RPM
  const curRPM = estimateRPM(raw.vss || raw.speed);
  updateEngineSound(curRPM);
  if (!engineSoundOn) document.getElementById('rpmReadout').textContent = `${Math.round(curRPM)} RPM`;

  // Live values
  updateValsGrid(r, raw);
}

function updateAfrBar(barId, valId, afr) {
  const pct = Math.max(0, Math.min(100, ((afr - 10) / 6) * 100));
  const el = document.getElementById(barId);
  if (el) { el.style.width = pct + '%'; el.style.background = afrToColor(afr); }
  if (valId) { const valEl = document.getElementById(valId); if (valEl) valEl.textContent = afr.toFixed(2); }
}

// ══════════ LIVE VALUES ══════════
function updateValsGrid(r, raw) {
  const el = document.getElementById('valsGrid');
  const items = [
    ['Speed', `${r.speed.toFixed(1)} mph`], ['VSS', `${r.vss.toFixed(1)} mph`],
    ['MAP', `${r.map.toFixed(1)} inHg`], ['Oil', `${r.oilp.toFixed(0)} psi`],
    ['Coolant', `${r.coolant.toFixed(0)} °F`], ['Alt', `${r.alt.toFixed(0)} ft`],
    ['Sats', `${raw.sats}`], ['Dir', `${r.dir.toFixed(0)}°`],
    ['Acc X', `${r.accx.toFixed(3)} g`], ['Acc Y', `${r.accy.toFixed(3)} g`],
    ['Acc Z', `${r.accz.toFixed(3)} g`], ['G-Force', `${Math.sqrt(r.accx**2+r.accy**2).toFixed(3)} g`],
    ['Rot X', `${r.rotx.toFixed(1)} dps`], ['Rot Y', `${r.roty.toFixed(1)} dps`],
    ['IMU Temp', `${r.imuTemp.toFixed(1)} °C`], ['Keyframe', raw.keyframe > 0 ? `#${raw.keyframe}` : '—'],
  ];
  el.innerHTML = items.map(([l,v]) => `<span class="vl">${l}</span><span class="vv">${v}</span>`).join('');
}

// ══════════ STATS TABLE ══════════
function buildStatsTable() {
  const tbody = document.querySelector('#statsTable tbody');
  tbody.innerHTML = '';
  Object.entries(CONDITIONS).forEach(([key, cond]) => {
    if (key === 'UNKNOWN') return;
    const cRows = rows.filter(r => r.condition === key);
    if (cRows.length === 0) { return; }
    const afrs = cRows.map(r => (r.afr + r.afr1) / 2);
    const avg = afrs.reduce((a,b) => a+b, 0) / afrs.length;
    const min = Math.min(...afrs);
    const max = Math.max(...afrs);
    const timeSec = cRows.length * SAMPLE_MS / 1000;
    const tr = document.createElement('tr');
    tr.innerHTML = `<td><span class="cond-dot" style="background:${cond.color};display:inline-block;width:8px;height:8px;border-radius:2px;margin-right:4px;vertical-align:middle"></span>${cond.label}</td><td>${cRows.length}</td><td>${fmtTime(timeSec)}</td><td>${avg.toFixed(2)}</td><td>${min.toFixed(2)}</td><td>${max.toFixed(2)}</td><td>${cond.afr[0]}–${cond.afr[1]}</td>`;
    tbody.appendChild(tr);
  });
}

// ══════════ G-G DIAGRAM ══════════
const GG_TRAIL_LEN = 40; // ~3.2s at 12.5Hz
const GG_MAX_G = 1.0;

function drawGG() {
  const canvas = document.getElementById('ggCanvas');
  if (!canvas) return;
  const dpr = window.devicePixelRatio || 1;
  const size = 360;
  canvas.width = size * dpr; canvas.height = size * dpr;
  canvas.style.width = size + 'px'; canvas.style.height = size + 'px';
  const ctx = canvas.getContext('2d');
  ctx.scale(dpr, dpr);
  const cx = size / 2, cy = size / 2, rad = size / 2 - 30;

  ctx.fillStyle = '#0f1a30';
  ctx.fillRect(0, 0, size, size);

  // Grid circles
  [0.25, 0.5, 0.75, 1.0].forEach(g => {
    ctx.strokeStyle = '#1a3a5c';
    ctx.lineWidth = 1;
    ctx.beginPath(); ctx.arc(cx, cy, rad * g, 0, Math.PI * 2); ctx.stroke();
    ctx.fillStyle = '#555';
    ctx.font = '10px sans-serif';
    ctx.textAlign = 'left';
    ctx.fillText(g.toFixed(2) + 'g', cx + rad * g + 2, cy - 4);
  });

  // Axes
  ctx.strokeStyle = '#2a4a6c';
  ctx.beginPath(); ctx.moveTo(cx - rad, cy); ctx.lineTo(cx + rad, cy); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(cx, cy - rad); ctx.lineTo(cx, cy + rad); ctx.stroke();

  // Axis labels
  ctx.fillStyle = '#666'; ctx.font = '10px sans-serif'; ctx.textAlign = 'center';
  ctx.fillText('Braking', cx, cy - rad - 4);
  ctx.fillText('Accel', cx, cy + rad + 12);
  ctx.fillText('Left', cx - rad - 2, cy + 12);
  ctx.textAlign = 'left';
  ctx.fillText('Right', cx + rad - 18, cy + 12);

  // Historical scatter: all points up to playIdx, very faint
  ctx.globalAlpha = 0.15;
  for (let i = 0; i <= Math.min(playIdx, rows.length - 1); i++) {
    const row = rows[i];
    const px = cx + (row.accy / GG_MAX_G) * rad;
    const py = cy - (row.accx / GG_MAX_G) * rad;
    const cond = CONDITIONS[row.condition];
    ctx.fillStyle = cond?.color || '#444';
    ctx.fillRect(px - 1, py - 1, 2, 2);
  }
  ctx.globalAlpha = 1;

  // Ghost trail: last GG_TRAIL_LEN samples
  const trailStart = Math.max(0, playIdx - GG_TRAIL_LEN);
  const trailEnd = Math.min(playIdx, rows.length - 1);
  const trail = [];
  for (let i = trailStart; i <= trailEnd; i++) {
    trail.push({
      px: cx + (rows[i].accy / GG_MAX_G) * rad,
      py: cy - (rows[i].accx / GG_MAX_G) * rad,
      cond: rows[i].condition,
    });
  }

  // Trail connecting line
  if (trail.length > 1) {
    ctx.beginPath();
    ctx.strokeStyle = 'rgba(79,195,247,0.4)';
    ctx.lineWidth = 1.5;
    trail.forEach((p, i) => { if (i === 0) ctx.moveTo(p.px, p.py); else ctx.lineTo(p.px, p.py); });
    ctx.stroke();
  }

  // Trail dots with fading
  trail.forEach((p, i) => {
    const age = trail.length - 1 - i;
    const alpha = Math.max(0.08, 1 - age / GG_TRAIL_LEN);
    const sz = 2 + (1 - age / GG_TRAIL_LEN) * 3;
    ctx.beginPath(); ctx.arc(p.px, p.py, sz, 0, Math.PI * 2);
    const cond = CONDITIONS[p.cond];
    ctx.fillStyle = cond?.color || '#888';
    ctx.globalAlpha = alpha * 0.6;
    ctx.fill();
  });
  ctx.globalAlpha = 1;

  // Current position: big bright dot
  if (trail.length > 0) {
    const cur = trail[trail.length - 1];
    // Glow
    ctx.beginPath(); ctx.arc(cur.px, cur.py, 12, 0, Math.PI * 2);
    ctx.fillStyle = 'rgba(79,195,247,0.15)'; ctx.fill();
    // Dot
    ctx.beginPath(); ctx.arc(cur.px, cur.py, 6, 0, Math.PI * 2);
    ctx.fillStyle = '#fff'; ctx.fill();
    ctx.strokeStyle = '#4fc3f7'; ctx.lineWidth = 2; ctx.stroke();
    // G readout near dot
    if (rows[playIdx]) {
      const gLat = rows[playIdx].accy;
      const gLon = rows[playIdx].accx;
      const gTotal = Math.sqrt(gLat**2 + gLon**2);
      ctx.fillStyle = '#ccc'; ctx.font = '10px sans-serif'; ctx.textAlign = 'left';
      ctx.fillText(`${gTotal.toFixed(2)}g`, cur.px + 10, cur.py - 4);
    }
  }
}

function updateGGStats(raw) {
  if (!raw || !rows.length) return;
  const gLat = raw.accy, gLon = raw.accx;
  const gCur = Math.sqrt(gLat**2 + gLon**2);

  // Compute stats from all rows up to playIdx
  let maxTotal = 0, maxBrake = 0, maxAccel = 0, maxLat = 0;
  let sumLat = 0, sumLon = 0, sumTotal = 0;
  const n = Math.min(playIdx + 1, rows.length);
  for (let i = 0; i < n; i++) {
    const r = rows[i];
    const lat = Math.abs(r.accy), lon = r.accx;
    const tot = Math.sqrt(r.accy**2 + r.accx**2);
    if (tot > maxTotal) maxTotal = tot;
    if (lon < -maxBrake) maxBrake = -lon;
    if (lon > maxAccel) maxAccel = lon;
    if (lat > maxLat) maxLat = lat;
    sumLat += lat; sumLon += Math.abs(lon); sumTotal += tot;
  }
  const avgTotal = n > 0 ? sumTotal / n : 0;

  // Update stats panel
  const el = document.getElementById('ggStats');
  if (el) {
    el.innerHTML = `<table>
      <tr><td>Current</td><td class="stat-val">${gCur.toFixed(3)}g</td></tr>
      <tr><td>Lat / Lon</td><td class="stat-val">${gLat.toFixed(3)} / ${gLon.toFixed(3)}</td></tr>
      <tr><td colspan="2" style="border-top:1px solid #1a3a5c;padding-top:6px;color:#4fc3f7;font-weight:500">Session Peak</td></tr>
      <tr><td>Max Total</td><td class="stat-val" style="color:#ef5350">${maxTotal.toFixed(3)}g</td></tr>
      <tr><td>Max Braking</td><td class="stat-val">${maxBrake.toFixed(3)}g</td></tr>
      <tr><td>Max Accel</td><td class="stat-val">${maxAccel.toFixed(3)}g</td></tr>
      <tr><td>Max Lateral</td><td class="stat-val">${maxLat.toFixed(3)}g</td></tr>
      <tr><td colspan="2" style="border-top:1px solid #1a3a5c;padding-top:6px;color:#4fc3f7;font-weight:500">Averages</td></tr>
      <tr><td>Avg G-Force</td><td class="stat-val">${avgTotal.toFixed(3)}g</td></tr>
      <tr><td>Avg Lateral</td><td class="stat-val">${(n>0?sumLat/n:0).toFixed(3)}g</td></tr>
      <tr><td>Avg Lon</td><td class="stat-val">${(n>0?sumLon/n:0).toFixed(3)}g</td></tr>
      <tr><td>Samples</td><td class="stat-val">${n.toLocaleString()}</td></tr>
    </table>`;
  }

  // Mini summary
  const curMini = document.getElementById('ggCurMini');
  const maxMini = document.getElementById('ggMaxMini');
  if (curMini) curMini.textContent = gCur.toFixed(2) + 'g';
  if (maxMini) maxMini.textContent = maxTotal.toFixed(2) + 'g';
}

// ══════════ KEYFRAMES ══════════
function buildKeyframeList() {
  const el = document.getElementById('keyframeList');
  const kfs = rows.filter(r => r.keyframe > 0);
  if (kfs.length === 0) { el.textContent = 'No keyframes in this log'; return; }
  el.innerHTML = '';
  kfs.forEach(r => {
    const btn = document.createElement('button');
    btn.textContent = `#${r.keyframe} @ ${fmtTime(r.time)}`;
    btn.style.cssText = 'background:#0f1a30;border:1px solid #2a4a6c;color:#4fc3f7;padding:4px 10px;border-radius:4px;cursor:pointer;font-size:0.8rem;margin:2px;';
    btn.onclick = () => { playIdx = r.idx; updatePlaybackUI(); };
    el.appendChild(btn);
  });
}

// ══════════ EXPORT ══════════
function exportSegment() {
  const header = 'time,lat,lon,speed,alt,dir,sats,accx,accy,accz,rotx,roty,rotz,magx,magy,magz,imuTemp,afr,afr1,vss,map,oilp,coolant,gpsStale,keyframe,condition\n';
  let csv = header;
  rows.forEach(r => {
    csv += [r.time,r.lat,r.lon,r.speed,r.alt,r.dir,r.sats,r.accx,r.accy,r.accz,r.rotx,r.roty,r.rotz,r.magx,r.magy,r.magz,r.imuTemp,r.afr,r.afr1,r.vss,r.map,r.oilp,r.coolant,r.gpsStale?1:0,r.keyframe,r.condition].join(',') + '\n';
  });
  const blob = new Blob([csv], { type: 'text/csv' });
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = filename.replace('.csv', '_analyzed.csv');
  a.click();
}

// ══════════ ENGINE SOUND SYNTHESIZER ══════════
// Simulates a V8 engine: 4 power strokes per revolution (firing freq = RPM/60*4)
// Layered: fundamental firing freq + sub-harmonics + exhaust rumble noise

let audioCtx = null, engineSoundOn = false;
let sndNodes = {}; // oscillator nodes and gains

function initAudioCtx() {
  if (!audioCtx) {
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  }
  if (audioCtx.state === 'suspended') audioCtx.resume();
}

function startEngineSound() {
  initAudioCtx();
  const master = audioCtx.createGain();
  const vol = parseInt(document.getElementById('sndVolume')?.value || 40) / 100;
  master.gain.setValueAtTime(vol * 0.5, audioCtx.currentTime);
  master.connect(audioCtx.destination);

  // === Layer 1: Primary firing frequency (sawtooth for aggressive V8 bark) ===
  const osc1 = audioCtx.createOscillator();
  const gain1 = audioCtx.createGain();
  osc1.type = 'sawtooth';
  osc1.frequency.setValueAtTime(46.7, audioCtx.currentTime); // 700 RPM idle: 700/60*4=46.7Hz
  gain1.gain.setValueAtTime(0.30, audioCtx.currentTime);
  osc1.connect(gain1);
  gain1.connect(master);
  osc1.start();

  // === Layer 2: Sub-harmonic (half firing freq — gives the "loping" V8 idle) ===
  const osc2 = audioCtx.createOscillator();
  const gain2 = audioCtx.createGain();
  osc2.type = 'triangle';
  osc2.frequency.setValueAtTime(23.3, audioCtx.currentTime); // half of firing freq
  gain2.gain.setValueAtTime(0.35, audioCtx.currentTime);
  osc2.connect(gain2);
  gain2.connect(master);
  osc2.start();

  // === Layer 3: Second harmonic (2x firing = individual cylinder pulses) ===
  const osc3 = audioCtx.createOscillator();
  const gain3 = audioCtx.createGain();
  osc3.type = 'square';
  osc3.frequency.setValueAtTime(93.3, audioCtx.currentTime);
  gain3.gain.setValueAtTime(0.08, audioCtx.currentTime);
  osc3.connect(gain3);
  gain3.connect(master);
  osc3.start();

  // === Layer 4: Low-frequency exhaust throb ===
  const osc4 = audioCtx.createOscillator();
  const gain4 = audioCtx.createGain();
  osc4.type = 'sine';
  osc4.frequency.setValueAtTime(11.7, audioCtx.currentTime); // quarter firing freq
  gain4.gain.setValueAtTime(0.20, audioCtx.currentTime);
  osc4.connect(gain4);
  gain4.connect(master);
  osc4.start();

  // === Layer 5: Noise burst — exhaust turbulence & mechanical clatter ===
  const noiseLen = 2; // seconds of noise buffer
  const noiseBuffer = audioCtx.createBuffer(1, audioCtx.sampleRate * noiseLen, audioCtx.sampleRate);
  const noiseData = noiseBuffer.getChannelData(0);
  for (let i = 0; i < noiseData.length; i++) noiseData[i] = Math.random() * 2 - 1;
  const noise = audioCtx.createBufferSource();
  noise.buffer = noiseBuffer;
  noise.loop = true;
  const noiseGain = audioCtx.createGain();
  noiseGain.gain.setValueAtTime(0.04, audioCtx.currentTime);
  // Band-pass the noise around firing freq for more realism
  const noiseBP = audioCtx.createBiquadFilter();
  noiseBP.type = 'bandpass';
  noiseBP.frequency.setValueAtTime(80, audioCtx.currentTime);
  noiseBP.Q.setValueAtTime(1.5, audioCtx.currentTime);
  noise.connect(noiseBP);
  noiseBP.connect(noiseGain);
  noiseGain.connect(master);
  noise.start();

  // === Master low-pass for muffled big-block character ===
  // Rewire: disconnect master from dest, put LP between
  master.disconnect();
  const lp = audioCtx.createBiquadFilter();
  lp.type = 'lowpass';
  lp.frequency.setValueAtTime(300, audioCtx.currentTime);
  lp.Q.setValueAtTime(2.0, audioCtx.currentTime);
  master.connect(lp);
  lp.connect(audioCtx.destination);

  sndNodes = { master, lp, osc1, gain1, osc2, gain2, osc3, gain3, osc4, gain4, noise, noiseGain, noiseBP };
  engineSoundOn = true;
  document.getElementById('btnSound').classList.add('snd-on');
  document.getElementById('btnSound').textContent = '\u{1F50A} Sound On';
}

function stopEngineSound() {
  if (sndNodes.osc1) { sndNodes.osc1.stop(); sndNodes.osc2.stop(); sndNodes.osc3.stop(); sndNodes.osc4.stop(); sndNodes.noise.stop(); }
  sndNodes = {};
  engineSoundOn = false;
  document.getElementById('btnSound').classList.remove('snd-on');
  document.getElementById('btnSound').textContent = '\u{1F509} Engine Sound';
}

function toggleEngineSound() {
  if (engineSoundOn) stopEngineSound(); else startEngineSound();
}

function setEngineVolume(val) {
  if (!sndNodes.master) return;
  const v = (parseInt(val) / 100) * 0.5;
  sndNodes.master.gain.setTargetAtTime(v, audioCtx.currentTime, 0.05);
}

function updateEngineSound(rpm) {
  if (!engineSoundOn || !sndNodes.osc1) return;
  const t = audioCtx.currentTime;
  const firingFreq = (rpm / 60) * 4; // 4 power strokes per rev for V8

  // Smoothly ramp frequencies
  sndNodes.osc1.frequency.setTargetAtTime(firingFreq, t, 0.06);
  sndNodes.osc2.frequency.setTargetAtTime(firingFreq * 0.5, t, 0.06);
  sndNodes.osc3.frequency.setTargetAtTime(firingFreq * 2, t, 0.06);
  sndNodes.osc4.frequency.setTargetAtTime(firingFreq * 0.25, t, 0.06);

  // Noise bandpass tracks firing freq
  sndNodes.noiseBP.frequency.setTargetAtTime(firingFreq * 1.5, t, 0.08);

  // Dynamic gain: louder at high RPM, sub-harmonic fades, harmonics grow
  const rpmNorm = Math.min(1, (rpm - 700) / 5500); // 0 at idle, 1 at 6200
  sndNodes.gain1.gain.setTargetAtTime(0.25 + rpmNorm * 0.15, t, 0.05);
  sndNodes.gain2.gain.setTargetAtTime(0.35 - rpmNorm * 0.15, t, 0.05); // sub-harmonic fades at high RPM
  sndNodes.gain3.gain.setTargetAtTime(0.06 + rpmNorm * 0.10, t, 0.05); // harmonics grow
  sndNodes.gain4.gain.setTargetAtTime(0.20 - rpmNorm * 0.08, t, 0.05);
  sndNodes.noiseGain.gain.setTargetAtTime(0.03 + rpmNorm * 0.06, t, 0.05); // more noise at high RPM

  // LP filter opens up at higher RPM — engine gets brighter
  sndNodes.lp.frequency.setTargetAtTime(250 + rpmNorm * 600, t, 0.08);

  // RPM display
  document.getElementById('rpmReadout').textContent = `${Math.round(rpm)} RPM`;
}

// ══════════ UTILS ══════════
function fmtTime(s) {
  const m = Math.floor(s / 60), sec = s % 60;
  return `${m}:${sec < 10 ? '0' : ''}${sec.toFixed(1)}`;
}

// ══════════ SYNTHETIC TEST DATA ══════════
// Realistic route: Potrero Hill → 101S → 280S → Portola Valley
function loadSyntheticData() {
  const rr = [];
  const lerp = (a, b, f) => a + (b - a) * f;
  const rnd = (lo, hi) => lo + Math.random() * (hi - lo);

  // GPS waypoints along Potrero Hill → 280 → Portola
  const waypoints = [
    { lat: 37.7598, lon: -122.3927 }, // Potrero Hill - 18th & Wisconsin
    { lat: 37.7558, lon: -122.3945 }, // Heading south on Wisconsin
    { lat: 37.7510, lon: -122.3988 }, // Down the hill to Cesar Chavez
    { lat: 37.7465, lon: -122.4035 }, // Cesar Chavez west
    { lat: 37.7380, lon: -122.4025 }, // 101 on-ramp area
    { lat: 37.7245, lon: -122.4050 }, // 101 south
    { lat: 37.7100, lon: -122.4120 }, // 101/280 junction
    { lat: 37.6950, lon: -122.4280 }, // 280 south past Daly City
    { lat: 37.6700, lon: -122.4420 }, // 280 Pacifica area
    { lat: 37.6400, lon: -122.4450 }, // 280 San Bruno Mtn
    { lat: 37.6100, lon: -122.4380 }, // 280 south
    { lat: 37.5800, lon: -122.4200 }, // 280 Crystal Springs
    { lat: 37.5500, lon: -122.3950 }, // 280 Woodside
    { lat: 37.5350, lon: -122.3800 }, // Sand Hill Rd exit
    { lat: 37.5200, lon: -122.3650 }, // Alpine Rd
    { lat: 37.5050, lon: -122.3580 }, // Portola Rd
    { lat: 37.4900, lon: -122.3500 }, // Portola Valley center
  ];

  // Scenario segments: condition, duration, speed range, MAP, AFR, G characteristics, notes
  const scenarios = [
    // Potrero Hill — cold-ish start, idle at top
    { dur: 6, spd: 0, map: 20, afr: 13.8, accx: 0, accy: 0, wp: [0,0], note: 'idle_hilltop', kf: true },
    // Pull out, gentle accel down Wisconsin
    { dur: 4, spd: [0, 25], map: [20, 10], afr: 12.8, accx: [0.1, 0.2], accy: 0, wp: [0,1] },
    // Steep downhill Potrero — braking, turns
    { dur: 6, spd: [25, 30], map: [16, 18], afr: 14.5, accx: [-0.3, -0.15], accy: [-0.2, 0.2], wp: [1,2] },
    // Stop sign at Cesar Chavez
    { dur: 3, spd: [30, 0], map: [18, 20], afr: 15.0, accx: [-0.4, -0.1], accy: 0, wp: [2,2] },
    { dur: 4, spd: 0, map: 20, afr: 13.7, accx: 0, accy: 0, wp: [2,2] },
    // Light on Cesar Chavez — pull out with authority, BURNOUT!
    { dur: 3, spd: [0, 15], map: [20, 2], afr: 11.8, accx: [0.4, 0.6], accy: [-0.05, 0.05], wp: [2,3], slip: 20 },
    // Continue accel to 101 on-ramp
    { dur: 5, spd: [15, 45], map: [4, 6], afr: 12.4, accx: [0.2, 0.35], accy: [-0.1, 0.1], wp: [3,4], kf: true },
    // 101 merge — hard accel
    { dur: 5, spd: [45, 70], map: [6, 2], afr: 12.2, accx: [0.3, 0.5], accy: [0, 0.15], wp: [4,5] },
    // 101 cruise
    { dur: 8, spd: 65, map: 10, afr: 13.7, accx: 0, accy: [-0.05, 0.05], wp: [5,6] },
    // 101/280 junction — slight decel and curve
    { dur: 4, spd: [65, 55], map: [10, 15], afr: 14.2, accx: [-0.1, 0], accy: [-0.25, -0.1], wp: [6,7] },
    // 280 south — open throttle, WOT run!
    { dur: 4, spd: [55, 85], map: [15, 1.5], afr: 12.3, accx: [0.3, 0.55], accy: [0, 0.1], wp: [7,8], kf: true },
    // 280 WOT continued
    { dur: 5, spd: [85, 95], map: 1.5, afr: 12.5, accx: [0.15, 0.3], accy: [-0.05, 0.05], wp: [8,9] },
    // 280 high speed cruise
    { dur: 10, spd: 75, map: 8, afr: 13.5, accx: [-0.02, 0.02], accy: [-0.08, 0.08], wp: [9,11] },
    // 280 sweeping curves — Crystal Springs
    { dur: 8, spd: 70, map: 9, afr: 13.6, accx: [-0.05, 0.05], accy: [-0.35, 0.35], wp: [11,12] },
    // Hard braking for Sand Hill exit — tires skid briefly
    { dur: 3, spd: [70, 35], map: [9, 20], afr: 15.5, accx: [-0.6, -0.35], accy: [0, 0.1], wp: [12,13], kf: true, slip: -8 },
    // Exit ramp decel
    { dur: 4, spd: [35, 15], map: [20, 18], afr: 14.8, accx: [-0.2, -0.1], accy: [-0.15, 0.15], wp: [13,14] },
    // Alpine Rd — moderate cruise through trees
    { dur: 8, spd: 35, map: 14, afr: 14.3, accx: [-0.05, 0.05], accy: [-0.2, 0.2], wp: [14,15] },
    // Portola Rd — light cruise, rolling hills
    { dur: 6, spd: 30, map: 16, afr: 14.5, accx: [-0.03, 0.08], accy: [-0.12, 0.12], wp: [15,16] },
    // Pull over, idle in Portola Valley
    { dur: 3, spd: [30, 0], map: [16, 20], afr: 15.0, accx: [-0.3, -0.1], accy: 0, wp: [16,16] },
    { dur: 5, spd: 0, map: 20, afr: 13.8, accx: 0, accy: 0, wp: [16,16], kf: true },
  ];

  let t = 0;
  let kfNum = 1;
  scenarios.forEach(sc => {
    const n = Math.round(sc.dur * 1000 / SAMPLE_MS);
    const wpStart = waypoints[sc.wp[0]], wpEnd = waypoints[sc.wp[1]];
    const hasKf = sc.kf && n > 2;
    const kfAt = hasKf ? Math.floor(n / 2) : -1;

    for (let i = 0; i < n; i++) {
      const frac = i / Math.max(1, n - 1);
      const s = Array.isArray(sc.spd) ? lerp(sc.spd[0], sc.spd[1], frac) : sc.spd;
      const m = (Array.isArray(sc.map) ? lerp(sc.map[0], sc.map[1], frac) : sc.map) + rnd(-0.3, 0.3);
      const afrBase = sc.afr + rnd(-0.2, 0.2);

      // GPS: interpolate between waypoints with slight wander
      const lat = lerp(wpStart.lat, wpEnd.lat, frac) + rnd(-0.0001, 0.0001);
      const lon = lerp(wpStart.lon, wpEnd.lon, frac) + rnd(-0.0001, 0.0001);
      const dir = Math.atan2(wpEnd.lon - wpStart.lon, wpEnd.lat - wpStart.lat) * 180 / Math.PI + rnd(-3, 3);

      // Acceleration
      const ax = Array.isArray(sc.accx) ? lerp(sc.accx[0], sc.accx[1], frac) + rnd(-0.03, 0.03) : rnd(-0.03, 0.03);
      const ay = Array.isArray(sc.accy) ? lerp(sc.accy[0], sc.accy[1], frac) + rnd(-0.02, 0.02) : rnd(-0.03, 0.03);

      // VSS: normally matches GPS speed, but slip scenarios diverge
      let vss = s + rnd(-1, 1);
      if (sc.slip) {
        // slip > 0 = wheelspin (VSS > GPS), slip < 0 = lockup (VSS < GPS)
        const slipPeak = Math.abs(sc.slip);
        const slipFrac = Math.sin(frac * Math.PI); // peaks in middle of segment
        vss = s + Math.sign(sc.slip) * slipPeak * slipFrac + rnd(-1, 1);
      }

      rr.push({
        idx: rr.length, time: t,
        lat, lon, speed: s, alt: lerp(90, 120, frac) + rnd(-2, 2),
        dir: ((dir % 360) + 360) % 360,
        sats: 10 + Math.floor(rnd(0, 4)),
        accx: ax, accy: ay, accz: -0.98 + rnd(-0.02, 0.02),
        rotx: rnd(-3, 3), roty: rnd(-3, 3), rotz: rnd(-1, 1),
        magx: 20 + rnd(0, 5), magy: -10 + rnd(0, 3), magz: 40 + rnd(0, 5),
        imuTemp: 28 + rnd(0, 2),
        afr: afrBase + rnd(-0.1, 0.1),
        afr1: afrBase + 0.15 + rnd(-0.1, 0.1),
        vss: Math.max(0, vss),
        map: Math.max(0, m),
        oilp: 55 + s * 0.08 + rnd(-2, 2),
        coolant: 185 + rnd(0, 5),
        gpsStale: false,
        keyframe: (i === kfAt) ? kfNum : 0,
        condition: 'UNKNOWN',
      });
      if (i === kfAt) kfNum++;
      t += SAMPLE_MS / 1000;
    }
  });

  rows = rr;
  filename = 'potrero_280_portola_demo.csv';
  detectAllConditions();
  applySmoothing();
  initUI();
}

// Resize handler
window.addEventListener('resize', () => { if (rows.length) drawHeatmap(); });

// Keyboard shortcuts
document.addEventListener('keydown', e => {
  if (e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT') return;
  if (e.code === 'Space') { e.preventDefault(); togglePlay(); }
  if (e.code === 'ArrowLeft') seekDelta(-1);
  if (e.code === 'ArrowRight') seekDelta(1);
});

// Add a "Load demo" link to upload zone
const demoLink = document.createElement('p');
demoLink.innerHTML = '<a href="#" style="color:#4fc3f7;font-size:0.8rem" id="loadDemo">or load synthetic demo data</a>';
document.getElementById('uploadZone').appendChild(demoLink);
document.getElementById('loadDemo').addEventListener('click', e => { e.preventDefault(); e.stopPropagation(); loadSyntheticData(); });
</script>
</body>
</html>
