<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Engine Calculator — 1969 Nova 454 BBC</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<style>
  * { box-sizing: border-box; margin: 0; padding: 0; }
  body { font-family: -apple-system, 'Segoe UI', Arial, sans-serif; background: #1a1a2e; color: #e0e0e0; min-height: 100vh; display: flex; justify-content: center; padding: 24px; }
  .container { max-width: 780px; width: 100%; }
  h1 { font-size: 1.4rem; color: #4fc3f7; margin-bottom: 4px; }
  .subtitle { color: #888; font-size: 0.85rem; margin-bottom: 20px; }
  .card { background: #16213e; border-radius: 10px; padding: 20px; margin-bottom: 14px; border: 1px solid #1a3a5c; }
  .card h2 { font-size: 1rem; color: #4fc3f7; margin-bottom: 14px; border-bottom: 1px solid #1a3a5c; padding-bottom: 8px; }
  .row { display: flex; align-items: center; margin-bottom: 10px; gap: 10px; }
  .row label { flex: 1; font-size: 0.85rem; color: #b0b0b0; }
  .row input, .row select { width: 90px; padding: 6px 8px; border: 1px solid #2a4a6c; border-radius: 5px; background: #0f1a30; color: #fff; font-size: 0.9rem; text-align: right; }
  .row select { width: 150px; text-align: left; }
  .row input:focus, .row select:focus { outline: none; border-color: #4fc3f7; }
  .row .unit { width: 44px; font-size: 0.8rem; color: #666; text-align: left; }
  .row .calc { color: #4fc3f7; font-size: 0.85rem; font-weight: 500; width: 90px; text-align: right; }
  .reset-btn { background: none; border: 1px solid #333; color: #888; padding: 4px 12px; border-radius: 4px; cursor: pointer; font-size: 0.75rem; }
  .reset-btn:hover { border-color: #4fc3f7; color: #4fc3f7; }

  /* Dashboard */
  .dash { background: linear-gradient(135deg, #1a3a5c, #16213e); border: 1px solid #4fc3f7; }
  .dash-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 12px; text-align: center; padding: 12px 0; }
  .dash-item .val { font-size: 2.2rem; font-weight: 700; color: #fff; }
  .dash-item .lbl { font-size: 0.75rem; color: #888; margin-top: 2px; }
  .dash-item .sub { font-size: 0.72rem; color: #4fc3f7; }
  .dash-item.hp .val { color: #ff7043; }
  .dash-item.hp .sub { color: #ff7043; }
  .dash-item.dcr .val { color: #ffa726; }
  .dash-item.dcr .sub { color: #ffa726; }
  .dash-row2 { display: grid; grid-template-columns: repeat(3, 1fr); gap: 12px; text-align: center; padding: 0 0 8px; }
  .dash-sm .val { font-size: 1.1rem; font-weight: 600; color: #ccc; }
  .dash-sm .lbl { font-size: 0.7rem; color: #666; }

  /* Chart */
  .chart-container { position: relative; width: 100%; height: 340px; margin: 12px 0; }
  canvas { width: 100%; height: 100%; }
  .chart-legend { display: flex; gap: 20px; justify-content: center; font-size: 0.78rem; margin-top: 6px; }
  .legend-item { display: flex; align-items: center; gap: 6px; }
  .legend-dot { width: 12px; height: 3px; border-radius: 2px; }

  /* Collapsible sections */
  details { margin-bottom: 14px; }
  details > summary { background: #16213e; border: 1px solid #1a3a5c; border-radius: 10px; padding: 12px 20px; cursor: pointer; font-size: 0.95rem; color: #4fc3f7; font-weight: 500; list-style: none; display: flex; justify-content: space-between; align-items: center; }
  details > summary::-webkit-details-marker { display: none; }
  details > summary::after { content: '▸'; transition: transform 0.2s; font-size: 0.8rem; color: #555; }
  details[open] > summary::after { transform: rotate(90deg); }
  details[open] > summary { border-radius: 10px 10px 0 0; border-bottom: 1px solid #1a3a5c; }
  details > .panel { background: #16213e; border: 1px solid #1a3a5c; border-top: none; border-radius: 0 0 10px 10px; padding: 16px 20px; }

  /* Flow table */
  .flow-row { display: grid; grid-template-columns: 60px 1fr 1fr; gap: 8px; margin-bottom: 6px; align-items: center; }
  .flow-row .lbl { font-size: 0.8rem; color: #888; }
  .flow-header { font-size: 0.75rem; color: #4fc3f7; font-weight: 600; }
  .flow-row input { width: 65px; padding: 4px 6px; font-size: 0.8rem; }

  /* Tables */
  table { width: 100%; border-collapse: collapse; font-size: 0.8rem; margin-top: 10px; }
  th { color: #4fc3f7; text-align: right; padding: 4px 8px; border-bottom: 1px solid #1a3a5c; }
  th:first-child { text-align: left; }
  td { text-align: right; padding: 4px 8px; color: #ccc; }
  td:first-child { text-align: left; color: #888; }
  tr.hl td { color: #4fc3f7; font-weight: 600; }
  tr.hl-hp td { color: #ff7043; font-weight: 600; }
  tr.hl-dcr td { color: #ffa726; font-weight: 600; }

  /* AFR matrix */
  .afr-matrix td { text-align: center; }
  .afr-matrix td:first-child { text-align: left; color: #ccc; }
  .afr-matrix th:first-child { text-align: left; }
  .afr-matrix th { text-align: center; }
  .afr-rich { color: #ff7043; font-weight: 600; }
  .afr-lean { color: #66bb6a; font-weight: 600; }
  .afr-notes { font-size: 0.75rem; color: #888; margin-top: 10px; line-height: 1.5; }
  .afr-notes strong { color: #b0b0b0; }

  /* AFR heatmap */
  .afr-heatmap-wrap { margin-top: 16px; }
  .afr-heatmap-wrap h3 { font-size: 0.9rem; color: #4fc3f7; margin-bottom: 8px; }
  #afrScene { width: 100%; height: 380px; border-radius: 6px; cursor: grab; }
  #afrScene:active { cursor: grabbing; }
  .afr-matrix tbody tr { cursor: pointer; transition: background 0.15s; }
  .afr-matrix tbody tr:hover { background: #1a3a5c; }
  .afr-matrix tbody tr.afr-active { background: #1a3a5c; }
  .afr-legend { display: flex; align-items: center; gap: 4px; font-size: 0.7rem; color: #888; margin-top: 6px; }
  .afr-legend-bar { flex: 1; height: 10px; border-radius: 3px; }
  .afr-view-btns { display: flex; gap: 6px; margin-top: 8px; }
  .afr-view-btns button { background: #0f1a30; border: 1px solid #2a4a6c; color: #b0b0b0; padding: 3px 10px; border-radius: 4px; cursor: pointer; font-size: 0.75rem; }
  .afr-view-btns button:hover, .afr-view-btns button.active { border-color: #4fc3f7; color: #4fc3f7; }

  .checkbox-row { display: flex; align-items: center; gap: 8px; margin-bottom: 10px; }
  .checkbox-row input[type="checkbox"] { width: auto; }
  .checkbox-row label { font-size: 0.85rem; color: #b0b0b0; flex: none; }
  .note { font-size: 0.73rem; color: #555; margin-top: 8px; font-style: italic; }
  .cam-tag { display: inline-block; padding: 2px 8px; border-radius: 3px; font-size: 0.7rem; font-weight: 600; margin-left: 6px; }
  .cam-roller { background: #ff7043; color: #1a1a2e; }
  .cam-flat { background: #4fc3f7; color: #1a1a2e; }
</style>
</head>
<body>
<div class="container">
  <h1>Engine Performance Calculator</h1>
  <p class="subtitle">1969 Chevrolet Nova — 454 BBC .030 Over &nbsp;|&nbsp; CR + DCR + Torque/HP from head flow & cam profile</p>

  <!-- ═══════════ DASHBOARD ═══════════ -->
  <div class="card dash">
    <div class="dash-grid">
      <div class="dash-item"><div class="val" id="dTq">—</div><div class="lbl">Peak Torque (lb-ft)</div><div class="sub" id="dTqAt">—</div></div>
      <div class="dash-item hp"><div class="val" id="dHp">—</div><div class="lbl">Peak Horsepower</div><div class="sub" id="dHpAt">—</div></div>
      <div class="dash-item"><div class="val" id="dCr">—</div><div class="lbl">Static CR</div><div class="sub">:1</div></div>
    </div>
    <div class="dash-row2">
      <div class="dash-sm"><div class="val" id="dDisp">—</div><div class="lbl">Displacement (ci)</div></div>
      <div class="dash-sm dcr"><div class="val" id="dDcr">—</div><div class="lbl">Dynamic CR</div></div>
      <div class="dash-sm"><div class="val" id="dVe">—</div><div class="lbl">Peak VE %</div></div>
    </div>
    <p class="note">Semi-empirical model from head flow + cam profile. ±5-8% vs dyno typical.</p>
  </div>

  <!-- ═══════════ CHART ═══════════ -->
  <div class="card">
    <div class="chart-container"><canvas id="chartCanvas"></canvas></div>
    <div class="chart-legend">
      <div class="legend-item"><div class="legend-dot" style="background:#4fc3f7"></div>Torque</div>
      <div class="legend-item"><div class="legend-dot" style="background:#ff7043"></div>HP</div>
      <div class="legend-item"><div class="legend-dot" style="background:#66bb6a"></div>VE %</div>
    </div>
    <div class="checkbox-row" style="justify-content:center;margin-top:10px">
      <input type="checkbox" id="showOldCam">
      <label for="showOldCam">Overlay previous cam (Performer RPM #7162)</label>
    </div>
  </div>

  <!-- ═══════════ COLLAPSIBLE INPUTS ═══════════ -->

  <details>
    <summary>Engine Dimensions</summary>
    <div class="panel">
      <div class="row"><label>Bore</label><input id="bore" type="number" step="0.001" value="4.280"><span class="unit">in</span></div>
      <div class="row"><label>Stroke</label><input id="stroke" type="number" step="0.001" value="4.000"><span class="unit">in</span></div>
      <div class="row"><label>Cylinders</label><input id="cylinders" type="number" step="1" value="8"><span class="unit"></span></div>
      <div class="row"><label>Rod Length (CTC)</label><input id="rodLen" type="number" step="0.001" value="6.385"><span class="unit">in</span></div>
      <div class="row"><label>Displacement</label><span class="calc" id="dispCi">—</span><span class="unit">ci</span></div>
    </div>
  </details>

  <details>
    <summary>Combustion Chamber & Gasket</summary>
    <div class="panel">
      <div class="row"><label>Chamber Volume</label><input id="chamber" type="number" step="0.1" value="110"><span class="unit">cc</span></div>
      <div class="row"><label>Dome Volume (+cc)</label><input id="dome" type="number" step="0.1" value="26"><span class="unit">cc</span></div>
      <div class="row"><label>Deck Clearance</label><input id="deck" type="number" step="0.001" value="0.020"><span class="unit">in</span></div>
      <div class="row"><label>Gasket Bore</label><input id="gasketBore" type="number" step="0.001" value="4.370"><span class="unit">in</span></div>
      <div class="row"><label>Gasket Thickness (compressed)</label><input id="gasketThick" type="number" step="0.001" value="0.039"><span class="unit">in</span></div>
    </div>
  </details>

  <details>
    <summary>Camshaft — Rollin' Thunder #2261</summary>
    <div class="panel">
      <div class="row"><label>Duration @ .050" (intake)</label><input id="intDur050" type="number" step="1" value="236"><span class="unit">°</span></div>
      <div class="row"><label>Advertised Duration (intake)</label><input id="intDurAdv" type="number" step="1" value="335"><span class="unit">°</span></div>
      <div class="row"><label>Max Intake Lift</label><input id="intLift" type="number" step="0.001" value="0.625"><span class="unit">in</span></div>
      <div class="row"><label>Intake Centerline</label><input id="intCL" type="number" step="1" value="109"><span class="unit">° ATDC</span></div>
      <div class="row"><label>Lobe Separation Angle</label><input id="lsa" type="number" step="1" value="112"><span class="unit">°</span></div>
      <div class="row"><label>Cam Type</label>
        <select id="camType"><option value="roller">Hydraulic Roller</option><option value="flat">Hydraulic Flat Tappet</option><option value="solid_roller">Solid Roller</option></select><span class="unit"></span></div>
      <div class="row"><label>Overlap (auto)</label><span class="calc" id="overlap">—</span><span class="unit">°</span></div>
      <div class="row"><label>IVC (° ABDC)</label><span class="calc" id="ivc">—</span><span class="unit">°</span></div>
    </div>
  </details>

  <details>
    <summary>Head Flow — Edelbrock #60459 @ 28" H₂O</summary>
    <div class="panel">
      <p class="note" style="margin-bottom:12px">Edit values to match your heads (ported, different brand, etc.)</p>
      <div class="flow-row"><span class="flow-header">Lift</span><span class="flow-header">Intake CFM</span><span class="flow-header">Exhaust CFM</span></div>
      <div class="flow-row"><span class="lbl">.100"</span><input class="flow-int" data-lift="0.100" type="number" value="74"><input class="flow-exh" data-lift="0.100" type="number" value="71"></div>
      <div class="flow-row"><span class="lbl">.200"</span><input class="flow-int" data-lift="0.200" type="number" value="143"><input class="flow-exh" data-lift="0.200" type="number" value="128"></div>
      <div class="flow-row"><span class="lbl">.300"</span><input class="flow-int" data-lift="0.300" type="number" value="207"><input class="flow-exh" data-lift="0.300" type="number" value="153"></div>
      <div class="flow-row"><span class="lbl">.400"</span><input class="flow-int" data-lift="0.400" type="number" value="250"><input class="flow-exh" data-lift="0.400" type="number" value="178"></div>
      <div class="flow-row"><span class="lbl">.500"</span><input class="flow-int" data-lift="0.500" type="number" value="284"><input class="flow-exh" data-lift="0.500" type="number" value="200"></div>
      <div class="flow-row"><span class="lbl">.600"</span><input class="flow-int" data-lift="0.600" type="number" value="309"><input class="flow-exh" data-lift="0.600" type="number" value="218"></div>
      <div class="flow-row"><span class="lbl">.700"</span><input class="flow-int" data-lift="0.700" type="number" value="315"><input class="flow-exh" data-lift="0.700" type="number" value="222"></div>
    </div>
  </details>

  <details>
    <summary>Intake & Exhaust</summary>
    <div class="panel">
      <div class="row"><label>Intake Manifold</label>
        <select id="manifold"><option value="dual_airgap">Dual Plane Air-Gap (#7561)</option><option value="dual_std">Dual Plane Standard</option><option value="single">Single Plane</option></select><span class="unit"></span></div>
      <div class="row"><label>Carburetor CFM</label><input id="carbCfm" type="number" step="1" value="850"><span class="unit">CFM</span></div>
      <div class="row"><label>Header Primary</label><input id="headerPri" type="number" step="0.125" value="1.875"><span class="unit">in</span></div>
      <div class="row"><label>Exhaust System</label>
        <select id="exhaustType"><option value="muffled">Full Exhaust w/ Mufflers</option><option value="cutouts">Open Cutouts</option><option value="race">Race Headers (open)</option></select><span class="unit"></span></div>
    </div>
  </details>

  <details>
    <summary>Conditions & RPM Range</summary>
    <div class="panel">
      <div class="row"><label>Altitude</label><input id="altitude" type="number" step="100" value="0"><span class="unit">ft</span></div>
      <div class="row"><label>Air Temperature</label><input id="airTemp" type="number" step="1" value="77"><span class="unit">°F</span></div>
      <div class="row"><label>WOT Air/Fuel Ratio</label><input id="afr" type="number" step="0.1" value="12.8"><span class="unit">:1</span></div>
      <div class="row"><label>Min RPM</label><input id="rpmMin" type="number" step="100" value="1500"><span class="unit">RPM</span></div>
      <div class="row"><label>Max RPM</label><input id="rpmMax" type="number" step="100" value="6500"><span class="unit">RPM</span></div>
      <div class="row"><label>Air Density Correction</label><span class="calc" id="densityCorr">—</span><span class="unit"></span></div>
    </div>
  </details>

  <div style="text-align:right;margin-bottom:18px"><button class="reset-btn" onclick="resetAll()">Reset All to Nova Defaults</button></div>

  <!-- ═══════════ DETAIL TABLES ═══════════ -->

  <details>
    <summary>CR Sensitivity — Deck Clearance Sweep</summary>
    <div class="panel">
      <table id="sensTable">
        <thead><tr><th>Deck (in)</th><th>Static CR</th><th>Dynamic CR</th></tr></thead>
        <tbody></tbody>
      </table>
    </div>
  </details>

  <details>
    <summary>Torque / HP Data Table</summary>
    <div class="panel">
      <table id="dataTable">
        <thead><tr><th>RPM</th><th>VE %</th><th>Torque</th><th>HP</th><th>BMEP</th></tr></thead>
        <tbody></tbody>
      </table>
    </div>
  </details>

  <details id="compDetail" style="display:none">
    <summary>Cam Comparison<span class="cam-tag cam-roller">Rollin' Thunder #2261</span><span class="cam-tag cam-flat">Performer RPM #7162</span></summary>
    <div class="panel">
      <table id="compTable">
        <thead><tr><th>RPM</th><th>TQ (roller)</th><th>HP (roller)</th><th>TQ (flat)</th><th>HP (flat)</th><th>ΔTQ</th><th>ΔHP</th></tr></thead>
        <tbody></tbody>
      </table>
    </div>
  </details>

  <details>
    <summary>AFR Target Guide — NA 454 BBC, Pump Gas</summary>
    <div class="panel">
      <table class="afr-matrix">
        <thead>
          <tr><th>Condition</th><th>RPM Range</th><th>Load</th><th>Target AFR</th><th>Notes</th></tr>
        </thead>
        <tbody>
          <tr><td>Cold Start</td><td>600–900</td><td>—</td><td class="afr-rich">11.5–12.5</td><td>Choke on, fast idle</td></tr>
          <tr><td>Warm Idle</td><td>700–850</td><td>—</td><td>13.5–14.0</td><td>Stable idle, low emissions</td></tr>
          <tr><td>Light Cruise</td><td>1500–2500</td><td>Low</td><td class="afr-lean">14.2–14.7</td><td>Steady-state, economy</td></tr>
          <tr><td>Moderate Cruise</td><td>2000–3500</td><td>Med</td><td>13.5–14.0</td><td>Mild throttle, part load</td></tr>
          <tr><td>Tip-In / Accel</td><td>Any</td><td>→High</td><td class="afr-rich">12.0–12.8</td><td>Accel pump enrichment</td></tr>
          <tr><td>WOT — Low RPM</td><td>2000–3500</td><td>Full</td><td class="afr-rich">12.5–13.0</td><td>Below torque peak, safe margin</td></tr>
          <tr><td>WOT — Mid RPM</td><td>3500–5000</td><td>Full</td><td class="afr-rich">12.5–12.8</td><td>Peak torque range, power sweet spot</td></tr>
          <tr><td>WOT — High RPM</td><td>5000–6500</td><td>Full</td><td class="afr-rich">12.2–12.8</td><td>Above peak HP, watch for lean</td></tr>
          <tr><td>Decel / Coast</td><td>Any</td><td>0</td><td class="afr-lean">14.7+</td><td>Closed throttle, fuel cut OK</td></tr>
        </tbody>
      </table>
      <div class="afr-notes">
        <strong>Quick reference:</strong> Stoich = 14.7 &nbsp;|&nbsp; Best power ≈ 12.5–12.8 &nbsp;|&nbsp; Rich limit ≈ 11.5 &nbsp;|&nbsp; Lean danger (WOT) &lt; 13.0+<br>
        For this combo (10.6:1 CR, pump 91), keep WOT no leaner than 13.0 to avoid detonation. Richer is safer when in doubt.
      </div>

      <div class="afr-heatmap-wrap">
        <h3>AFR Map — Load vs RPM (3D)</h3>
        <div id="afrScene"></div>
        <div class="afr-legend">
          <span>Rich 11.0</span>
          <div class="afr-legend-bar" id="afrLegendBar"></div>
          <span>15.0 Lean</span>
        </div>
        <div class="afr-view-btns">
          <button onclick="setView('angle')">3D Angle</button>
          <button onclick="setView('top')">Top Down</button>
          <button onclick="setView('front')">Front</button>
          <button onclick="setView('side')">Side</button>
        </div>
        <div class="afr-notes" style="margin-top:6px">Drag to rotate, scroll to zoom. Click a condition row above to highlight its region.</div>
      </div>
    </div>
  </details>
</div>

<script>
const $ = id => document.getElementById(id);
const val = id => parseFloat($(id).value) || 0;

// ══════════ COMPRESSION RATIO ══════════

function calcCompression(bore, stroke, cyl, chamber, dome, deck, gasketBore, gasketThick, rodLen, intDur050, intCL) {
  const swept = (Math.PI / 4) * bore * bore * stroke;
  const sweptCC = swept * 16.387064;
  const deckCC = (Math.PI / 4) * bore * bore * deck * 16.387064;
  const gasketCC = (Math.PI / 4) * gasketBore * gasketBore * gasketThick * 16.387064;
  const clearance = chamber + gasketCC + deckCC - dome;
  const cr = (sweptCC + clearance) / clearance;

  // Dynamic CR — piston position at IVC
  const ivcABDC = intCL + (intDur050 / 2) - 180;
  const r = stroke / 2;
  const l = rodLen;
  const thetaRad = ivcABDC * Math.PI / 180;
  const sinT = Math.sin(thetaRad);
  const cosT = Math.cos(thetaRad);
  const pistonFromBDC = r * (1 - cosT) + l * (1 - Math.sqrt(1 - (r / l) * (r / l) * sinT * sinT));
  const lostStroke = pistonFromBDC;
  const effStroke = stroke - lostStroke;
  const effSwept = (Math.PI / 4) * bore * bore * effStroke;
  const effSweptCC = effSwept * 16.387064;
  const dcr = (effSweptCC + clearance) / clearance;

  return { cr, dcr, clearance, sweptCC, gasketCC, deckCC, ivcABDC, effStroke, effSweptCC, lostStroke };
}

// ══════════ HEAD FLOW ══════════

function getFlowData() {
  const intakes = [], exhausts = [];
  document.querySelectorAll('.flow-int').forEach(el => {
    intakes.push({ lift: parseFloat(el.dataset.lift), cfm: parseFloat(el.value) || 0 });
  });
  document.querySelectorAll('.flow-exh').forEach(el => {
    exhausts.push({ lift: parseFloat(el.dataset.lift), cfm: parseFloat(el.value) || 0 });
  });
  return { intakes, exhausts };
}

function interpolateFlow(table, lift) {
  if (lift <= 0) return 0;
  if (lift <= table[0].lift) return table[0].cfm * (lift / table[0].lift);
  for (let i = 1; i < table.length; i++) {
    if (lift <= table[i].lift) {
      const t = (lift - table[i-1].lift) / (table[i].lift - table[i-1].lift);
      return table[i-1].cfm + t * (table[i].cfm - table[i-1].cfm);
    }
  }
  const last = table[table.length - 1], prev = table[table.length - 2];
  return last.cfm + (last.cfm - prev.cfm) / (last.lift - prev.lift) * 0.3 * (lift - last.lift);
}

// ══════════ CAM LIFT PROFILE ══════════

function camLiftProfile(theta, maxLift, durAdv, dur050) {
  if (theta <= 0 || theta >= durAdv) return 0;
  const theta050 = (durAdv - dur050) / 2;
  const sinVal = Math.sin(Math.PI * theta050 / durAdv);
  const n = Math.log(0.050 / maxLift) / Math.log(sinVal);
  return maxLift * Math.pow(Math.max(Math.sin(Math.PI * theta / durAdv), 0), n);
}

function calcMeanIntakeFlow(maxLift, durAdv, dur050, flowTable) {
  const steps = 72, dTheta = durAdv / steps;
  let total = 0;
  for (let i = 0; i < steps; i++) total += interpolateFlow(flowTable, camLiftProfile((i + 0.5) * dTheta, maxLift, durAdv, dur050));
  return total / steps;
}

// ══════════ VOLUMETRIC EFFICIENCY ══════════

function calcVE(rpm, cfg) {
  const { cid, cidPerCyl, meanIntFlow, durAdv, intCL, lsa, manifold, exhaustType, carbCfm, camType, densityFactor } = cfg;
  const dutyCycle = durAdv / 720;
  const headCapacity = meanIntFlow * dutyCycle;
  const demandPerCyl = (cidPerCyl * rpm) / 3456;
  const headRatio = headCapacity / Math.max(demandPerCyl, 0.1);
  const ve_head = headRatio > 1 ? 1.0 - 0.02 * (headRatio - 1) : Math.pow(headRatio, 0.7);

  let rpmPeakRam, ramWidth, ramBoost;
  if (manifold === 'single') { rpmPeakRam = 6000; ramWidth = 2000; ramBoost = 0.06; }
  else if (manifold === 'dual_airgap') { rpmPeakRam = 4200; ramWidth = 2500; ramBoost = 0.08; }
  else { rpmPeakRam = 3800; ramWidth = 2200; ramBoost = 0.06; }
  const ramDelta = (rpm - rpmPeakRam) / ramWidth;
  const ve_ram = 1.0 + ramBoost * Math.exp(-ramDelta * ramDelta);

  const overlapDeg = Math.max(0, durAdv - 360);
  const ve_reversion = 1.0 - Math.max(0, overlapDeg / 100) * Math.max(0, 1 - rpm / 2000);

  let exhFactor = exhaustType === 'race' ? 0.0 : exhaustType === 'cutouts' ? 0.02 : 0.08;
  const rpmMax = val('rpmMax') || 6500;
  const ve_exhaust = 1.0 - exhFactor * Math.pow(rpm / rpmMax, 2);

  const totalDemand = (cid * rpm) / 3456;
  const carbRatio = totalDemand / carbCfm;
  const ve_carb = carbRatio < 0.85 ? 1.0 : 1.0 - 0.3 * Math.pow((carbRatio - 0.85) / 0.15, 2);

  const camBonus = camType === 'roller' ? 1.03 : camType === 'solid_roller' ? 1.05 : 1.0;

  return Math.max(0.3, Math.min(1.05, ve_head * ve_ram * ve_reversion * ve_exhaust * ve_carb * camBonus * densityFactor));
}

// ══════════ TORQUE / HP ══════════

function calcTorqueHP(rpm, ve, cfg) {
  const K_imep = 200 + 3.5 * (cfg.cr - 9.0);
  const fmep = 12 + 0.004 * rpm;
  const bmep = Math.max(0, K_imep * ve - fmep);
  const torque = bmep * cfg.cid / 150.8;
  return { torque, hp: torque * rpm / 5252, bmep, ve };
}

function calcDensityFactor() {
  const alt = val('altitude'), tempF = val('airTemp');
  return Math.pow(1 - 6.8753e-6 * alt, 5.2559) / ((tempF + 459.67) / 518.67);
}

// ══════════ MAIN CALCULATE ══════════

function calculate() {
  const bore = val('bore'), stroke = val('stroke'), cyl = val('cylinders');
  const chamber = val('chamber'), dome = val('dome'), deck = val('deck');
  const gasketBore = val('gasketBore'), gasketThick = val('gasketThick');
  const rodLen = val('rodLen');
  const intDur050 = val('intDur050'), intDurAdv = val('intDurAdv');
  const intLift = val('intLift'), intCL = val('intCL'), lsa = val('lsa');
  const camType = $('camType').value;
  const manifold = $('manifold').value;
  const carbCfm = val('carbCfm'), exhaustType = $('exhaustType').value;
  const rpmMin = val('rpmMin'), rpmMax = val('rpmMax');

  // Displacement
  const cid = (Math.PI / 4) * bore * bore * stroke * cyl;
  const cidPerCyl = cid / cyl;
  $('dispCi').textContent = cid.toFixed(1);
  $('dDisp').textContent = cid.toFixed(0);

  // Compression
  const comp = calcCompression(bore, stroke, cyl, chamber, dome, deck, gasketBore, gasketThick, rodLen, intDur050, intCL);
  $('dCr').textContent = comp.cr.toFixed(1);
  $('dDcr').textContent = comp.dcr.toFixed(1) + ':1';
  $('overlap').textContent = Math.max(0, intDurAdv - 360).toFixed(0);
  $('ivc').textContent = comp.ivcABDC.toFixed(0);

  // Density
  const densityFactor = calcDensityFactor();
  $('densityCorr').textContent = (densityFactor * 100).toFixed(1) + '%';

  // Head flow
  const flowData = getFlowData();
  const meanIntFlow = calcMeanIntakeFlow(intLift, intDurAdv, intDur050, flowData.intakes);

  const cfg = { cid, cidPerCyl, cr: comp.cr, meanIntFlow, durAdv: intDurAdv, dur050: intDur050,
    maxLift: intLift, intCL, lsa, manifold, exhaustType, carbCfm, camType, densityFactor };

  // Torque/HP sweep
  const results = [];
  let peakTq = 0, peakTqRpm = 0, peakHp = 0, peakHpRpm = 0, peakVe = 0;
  for (let rpm = rpmMin; rpm <= rpmMax; rpm += 100) {
    const ve = calcVE(rpm, cfg);
    const r = calcTorqueHP(rpm, ve, cfg);
    results.push({ rpm, ...r });
    if (r.torque > peakTq) { peakTq = r.torque; peakTqRpm = rpm; peakVe = r.ve; }
    if (r.hp > peakHp) { peakHp = r.hp; peakHpRpm = rpm; }
  }

  // Dashboard
  $('dTq').textContent = Math.round(peakTq);
  $('dTqAt').textContent = '@ ' + peakTqRpm + ' RPM';
  $('dHp').textContent = Math.round(peakHp);
  $('dHpAt').textContent = '@ ' + peakHpRpm + ' RPM';
  $('dVe').textContent = (peakVe * 100).toFixed(1) + '%';

  // Old cam
  let oldResults = null;
  if ($('showOldCam').checked) {
    const oldMeanFlow = calcMeanIntakeFlow(0.560, 300, 240, flowData.intakes);
    const oldCfg = { ...cfg, meanIntFlow: oldMeanFlow, durAdv: 300, dur050: 240, maxLift: 0.560, intCL: 110, camType: 'flat' };
    oldResults = [];
    for (let rpm = rpmMin; rpm <= rpmMax; rpm += 100) {
      const ve = calcVE(rpm, oldCfg);
      oldResults.push({ rpm, ...calcTorqueHP(rpm, ve, oldCfg) });
    }
    $('compDetail').style.display = '';
  } else {
    $('compDetail').style.display = 'none';
  }

  drawChart(results, oldResults);
  fillDataTable(results, peakTqRpm, peakHpRpm);
  fillSensitivity(bore, stroke, cyl, chamber, dome, gasketBore, gasketThick, rodLen, intDur050, intCL, deck);
  if (oldResults) fillCompTable(results, oldResults);
}

// ══════════ CHART ══════════

function drawChart(results, oldResults) {
  const canvas = $('chartCanvas'), ctx = canvas.getContext('2d');
  const dpr = window.devicePixelRatio || 1;
  const rect = canvas.parentElement.getBoundingClientRect();
  canvas.width = rect.width * dpr; canvas.height = rect.height * dpr;
  ctx.scale(dpr, dpr);
  const W = rect.width, H = rect.height;
  const pad = { top: 20, right: 60, bottom: 40, left: 60 };
  const plotW = W - pad.left - pad.right, plotH = H - pad.top - pad.bottom;
  ctx.clearRect(0, 0, W, H);

  const rpmMin = results[0].rpm, rpmMax = results[results.length - 1].rpm;
  let maxTq = 0, maxHp = 0;
  results.forEach(r => { maxTq = Math.max(maxTq, r.torque); maxHp = Math.max(maxHp, r.hp); });
  if (oldResults) oldResults.forEach(r => { maxTq = Math.max(maxTq, r.torque); maxHp = Math.max(maxHp, r.hp); });
  const tqS = Math.ceil(maxTq / 50) * 50 + 50, hpS = Math.ceil(maxHp / 50) * 50 + 50;

  const xOf = rpm => pad.left + (rpm - rpmMin) / (rpmMax - rpmMin) * plotW;
  const yTq = tq => pad.top + (1 - tq / tqS) * plotH;
  const yHp = hp => pad.top + (1 - hp / hpS) * plotH;

  // Grid
  ctx.strokeStyle = '#1a3a5c'; ctx.lineWidth = 0.5;
  for (let t = 0; t <= tqS; t += 100) { ctx.beginPath(); ctx.moveTo(pad.left, yTq(t)); ctx.lineTo(W - pad.right, yTq(t)); ctx.stroke(); }
  for (let rpm = rpmMin; rpm <= rpmMax; rpm += 500) { ctx.beginPath(); ctx.moveTo(xOf(rpm), pad.top); ctx.lineTo(xOf(rpm), H - pad.bottom); ctx.stroke(); }

  // Labels
  ctx.fillStyle = '#888'; ctx.font = '11px -apple-system, sans-serif'; ctx.textAlign = 'center';
  for (let rpm = rpmMin; rpm <= rpmMax; rpm += 1000) ctx.fillText(rpm, xOf(rpm), H - pad.bottom + 18);
  ctx.fillText('RPM', pad.left + plotW / 2, H - 4);
  ctx.textAlign = 'right';
  for (let t = 0; t <= tqS; t += 100) { ctx.fillStyle = '#4fc3f7'; ctx.fillText(t, pad.left - 8, yTq(t) + 4); }
  ctx.textAlign = 'left';
  for (let h = 0; h <= hpS; h += 100) { ctx.fillStyle = '#ff7043'; ctx.fillText(h, W - pad.right + 8, yHp(h) + 4); }

  // Old cam (dashed)
  if (oldResults) {
    ctx.setLineDash([6, 4]); ctx.lineWidth = 1.5;
    ctx.strokeStyle = '#4fc3f788'; ctx.beginPath();
    oldResults.forEach((r, i) => { i === 0 ? ctx.moveTo(xOf(r.rpm), yTq(r.torque)) : ctx.lineTo(xOf(r.rpm), yTq(r.torque)); }); ctx.stroke();
    ctx.strokeStyle = '#ff704388'; ctx.beginPath();
    oldResults.forEach((r, i) => { i === 0 ? ctx.moveTo(xOf(r.rpm), yHp(r.hp)) : ctx.lineTo(xOf(r.rpm), yHp(r.hp)); }); ctx.stroke();
    ctx.setLineDash([]);
  }

  // Torque
  ctx.lineWidth = 2.5; ctx.strokeStyle = '#4fc3f7'; ctx.beginPath();
  results.forEach((r, i) => { i === 0 ? ctx.moveTo(xOf(r.rpm), yTq(r.torque)) : ctx.lineTo(xOf(r.rpm), yTq(r.torque)); }); ctx.stroke();

  // HP
  ctx.strokeStyle = '#ff7043'; ctx.beginPath();
  results.forEach((r, i) => { i === 0 ? ctx.moveTo(xOf(r.rpm), yHp(r.hp)) : ctx.lineTo(xOf(r.rpm), yHp(r.hp)); }); ctx.stroke();

  // VE (scaled to torque axis as percentage)
  const veScale = tqS / 100;
  ctx.strokeStyle = '#66bb6a88'; ctx.lineWidth = 1; ctx.setLineDash([3, 3]); ctx.beginPath();
  results.forEach((r, i) => { const y = yTq(r.ve * 100 * veScale); i === 0 ? ctx.moveTo(xOf(r.rpm), y) : ctx.lineTo(xOf(r.rpm), y); }); ctx.stroke();
  ctx.setLineDash([]);

  // Peak markers
  const ptq = results.reduce((a, b) => b.torque > a.torque ? b : a);
  const php = results.reduce((a, b) => b.hp > a.hp ? b : a);
  ctx.beginPath(); ctx.arc(xOf(ptq.rpm), yTq(ptq.torque), 5, 0, Math.PI * 2); ctx.fillStyle = '#4fc3f7'; ctx.fill();
  ctx.beginPath(); ctx.arc(xOf(php.rpm), yHp(php.hp), 5, 0, Math.PI * 2); ctx.fillStyle = '#ff7043'; ctx.fill();
}

// ══════════ TABLES ══════════

function fillDataTable(results, peakTqRpm, peakHpRpm) {
  const tbody = $('dataTable').querySelector('tbody');
  tbody.innerHTML = '';
  results.filter(r => r.rpm % 500 === 0).forEach(r => {
    const tr = document.createElement('tr');
    if (r.rpm === peakTqRpm) tr.className = 'hl';
    else if (r.rpm === peakHpRpm) tr.className = 'hl-hp';
    tr.innerHTML = `<td>${r.rpm}</td><td>${(r.ve*100).toFixed(1)}</td><td>${r.torque.toFixed(0)}</td><td>${r.hp.toFixed(0)}</td><td>${r.bmep.toFixed(1)}</td>`;
    tbody.appendChild(tr);
  });
}

function fillSensitivity(bore, stroke, cyl, chamber, dome, gasketBore, gasketThick, rodLen, intDur050, intCL, currentDeck) {
  const tbody = $('sensTable').querySelector('tbody');
  tbody.innerHTML = '';
  for (let d = 0; d <= 0.030; d += 0.005) {
    const dk = Math.round(d * 1000) / 1000;
    const c = calcCompression(bore, stroke, cyl, chamber, dome, dk, gasketBore, gasketThick, rodLen, intDur050, intCL);
    const tr = document.createElement('tr');
    if (Math.abs(dk - currentDeck) < 0.001) tr.className = 'hl';
    tr.innerHTML = `<td>${dk.toFixed(3)}"</td><td>${c.cr.toFixed(2)}:1</td><td>${c.dcr.toFixed(2)}:1</td>`;
    tbody.appendChild(tr);
  }
}

function fillCompTable(newR, oldR) {
  const tbody = $('compTable').querySelector('tbody');
  tbody.innerHTML = '';
  newR.filter(r => r.rpm % 500 === 0).forEach(r => {
    const o = oldR.find(x => x.rpm === r.rpm);
    if (!o) return;
    const dtq = r.torque - o.torque, dhp = r.hp - o.hp;
    const tr = document.createElement('tr');
    tr.innerHTML = `<td>${r.rpm}</td><td>${r.torque.toFixed(0)}</td><td>${r.hp.toFixed(0)}</td><td>${o.torque.toFixed(0)}</td><td>${o.hp.toFixed(0)}</td><td style="color:${dtq>=0?'#66bb6a':'#ef5350'}">${dtq>=0?'+':''}${dtq.toFixed(0)}</td><td style="color:${dhp>=0?'#66bb6a':'#ef5350'}">${dhp>=0?'+':''}${dhp.toFixed(0)}</td>`;
    tbody.appendChild(tr);
  });
}

// ══════════ RESET ══════════

function resetAll() {
  const d = { bore:4.280, stroke:4.000, cylinders:8, rodLen:6.385, chamber:110, dome:26, deck:0.020,
    gasketBore:4.370, gasketThick:0.039, intDur050:236, intDurAdv:335, intLift:0.625, intCL:109, lsa:112,
    carbCfm:850, headerPri:1.875, altitude:0, airTemp:77, afr:12.8, rpmMin:1500, rpmMax:6500 };
  Object.entries(d).forEach(([k,v]) => { if ($(k)) $(k).value = v; });
  $('camType').value = 'roller'; $('manifold').value = 'dual_airgap'; $('exhaustType').value = 'muffled';
  $('showOldCam').checked = false;
  const intF = [74,143,207,250,284,309,315], exhF = [71,128,153,178,200,218,222];
  document.querySelectorAll('.flow-int').forEach((el,i) => el.value = intF[i]);
  document.querySelectorAll('.flow-exh').forEach((el,i) => el.value = exhF[i]);
  calculate();
}

// ══════════ AFR 3D SURFACE ══════════

const afrRpms = [500, 1000, 1500, 2000, 2500, 3000, 3500, 4000, 4500, 5000, 5500, 6000, 6500];
const afrLoads = ['WOT', '75%', '50%', '25%', 'Idle/Decel'];
const afrMap = [
  [12.0, 12.0, 12.8, 12.8, 12.8, 12.8, 12.6, 12.6, 12.5, 12.5, 12.4, 12.3, 12.2],
  [12.5, 12.8, 13.2, 13.2, 13.0, 13.0, 12.8, 12.8, 12.6, 12.6, 12.5, 12.4, 12.3],
  [13.0, 13.5, 14.0, 13.8, 13.6, 13.5, 13.2, 13.0, 13.0, 12.8, 12.8, 12.6, 12.5],
  [13.5, 13.8, 14.5, 14.5, 14.2, 14.0, 13.8, 13.5, 13.2, 13.0, 13.0, 12.8, 12.8],
  [14.0, 13.8, 14.7, 14.7, 14.7, 14.7, 14.7, 14.7, 14.7, 14.7, 14.7, 14.7, 14.7],
];
const conditionRegions = [
  { rpmMin:500,  rpmMax:1000, rows:[4] },
  { rpmMin:500,  rpmMax:1000, rows:[4] },
  { rpmMin:1500, rpmMax:2500, rows:[3,4] },
  { rpmMin:2000, rpmMax:3500, rows:[2,3] },
  { rpmMin:500,  rpmMax:6500, rows:[0,1] },
  { rpmMin:2000, rpmMax:3500, rows:[0] },
  { rpmMin:3500, rpmMax:5000, rows:[0] },
  { rpmMin:5000, rpmMax:6500, rows:[0] },
  { rpmMin:500,  rpmMax:6500, rows:[4] },
];

function afrColorRGB(afr) {
  const t = Math.max(0, Math.min(1, (afr - 11.0) / (15.0 - 11.0)));
  let r, g, b;
  if (t < 0.35) {
    const s = t / 0.35;
    r = 255; g = 70 + s * 100; b = 30 + s * 30;
  } else if (t < 0.65) {
    const s = (t - 0.35) / 0.3;
    r = 255 - s * 120; g = 170 + s * 60; b = 60 + s * 40;
  } else {
    const s = (t - 0.65) / 0.35;
    r = 135 - s * 70; g = 230 - s * 40; b = 100 + s * 60;
  }
  return { r: r / 255, g: g / 255, b: b / 255 };
}

// Three.js scene
let scene, camera, renderer, surfaceMesh, edgesMesh, hlMesh;
let activeCondition = -1;
let isDragging = false, prevMouse = { x: 0, y: 0 };
let camTheta = 0.8, camPhi = 0.55, camDist = 8.5;

const GRID_W = 6, GRID_D = 3; // world units for RPM and Load axes
const AFR_MIN = 11.0, AFR_MAX = 15.0, AFR_HEIGHT = 2.5; // height scale

function afrToY(afr) {
  // Invert: lower AFR (richer) = taller bar (more fuel)
  return ((afr - AFR_MIN) / (AFR_MAX - AFR_MIN)) * AFR_HEIGHT;
}

function initAfrScene() {
  const container = $('afrScene');
  if (!container) return;
  const W = container.clientWidth, H = 380;

  scene = new THREE.Scene();
  camera = new THREE.PerspectiveCamera(40, W / H, 0.1, 100);
  renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
  renderer.setSize(W, H);
  renderer.setPixelRatio(window.devicePixelRatio);
  renderer.setClearColor(0x1a1a2e, 1);
  container.appendChild(renderer.domElement);

  // Lights
  const amb = new THREE.AmbientLight(0xffffff, 0.45);
  scene.add(amb);
  const dir = new THREE.DirectionalLight(0xffffff, 0.7);
  dir.position.set(5, 8, 4);
  scene.add(dir);
  const dir2 = new THREE.DirectionalLight(0x4fc3f7, 0.25);
  dir2.position.set(-3, 4, -2);
  scene.add(dir2);

  buildSurface();
  buildGrid();
  buildLabels();
  updateCamera();
  animate();

  // Mouse controls
  container.addEventListener('mousedown', e => { isDragging = true; prevMouse = { x: e.clientX, y: e.clientY }; });
  window.addEventListener('mouseup', () => isDragging = false);
  window.addEventListener('mousemove', e => {
    if (!isDragging) return;
    const dx = e.clientX - prevMouse.x, dy = e.clientY - prevMouse.y;
    camTheta -= dx * 0.008;
    camPhi = Math.max(0.1, Math.min(Math.PI / 2 - 0.05, camPhi + dy * 0.008));
    prevMouse = { x: e.clientX, y: e.clientY };
    updateCamera();
  });
  container.addEventListener('wheel', e => {
    e.preventDefault();
    camDist = Math.max(4, Math.min(18, camDist + e.deltaY * 0.01));
    updateCamera();
  }, { passive: false });

  // Legend
  const bar = $('afrLegendBar');
  if (bar) bar.style.background = 'linear-gradient(to right, rgb(255,70,30), rgb(255,170,60), rgb(135,230,100), rgb(65,190,160))';
}

function updateCamera() {
  const cx = GRID_W / 2, cz = GRID_D / 2, cy = AFR_HEIGHT * 0.4;
  camera.position.set(
    cx + camDist * Math.sin(camPhi) * Math.sin(camTheta),
    cy + camDist * Math.cos(camPhi),
    cz + camDist * Math.sin(camPhi) * Math.cos(camTheta)
  );
  camera.lookAt(cx, cy, cz);
}

function buildSurface() {
  const rows = afrMap.length, cols = afrMap[0].length;
  // Create geometry with per-cell quads (flat shading, per-face color)
  const geo = new THREE.BufferGeometry();
  const verts = [], normals = [], colors = [], indices = [];
  const cellW = GRID_W / (cols - 1), cellD = GRID_D / (rows - 1);

  // Build smooth surface vertices
  const posGrid = [];
  for (let ri = 0; ri < rows; ri++) {
    const row = [];
    for (let ci = 0; ci < cols; ci++) {
      row.push(new THREE.Vector3(ci * cellW, afrToY(afrMap[ri][ci]), ri * cellD));
    }
    posGrid.push(row);
  }

  // Quads → 2 triangles each, with per-face vertices for flat color
  let vi = 0;
  for (let ri = 0; ri < rows - 1; ri++) {
    for (let ci = 0; ci < cols - 1; ci++) {
      const p00 = posGrid[ri][ci], p10 = posGrid[ri][ci + 1];
      const p01 = posGrid[ri + 1][ci], p11 = posGrid[ri + 1][ci + 1];
      // Average AFR for color
      const avgAfr = (afrMap[ri][ci] + afrMap[ri][ci + 1] + afrMap[ri + 1][ci] + afrMap[ri + 1][ci + 1]) / 4;
      const c = afrColorRGB(avgAfr);

      // Normal for this quad
      const e1 = new THREE.Vector3().subVectors(p10, p00);
      const e2 = new THREE.Vector3().subVectors(p01, p00);
      const n = new THREE.Vector3().crossVectors(e1, e2).normalize();

      // Triangle 1: p00, p10, p01
      [p00, p10, p01].forEach(p => {
        verts.push(p.x, p.y, p.z);
        normals.push(n.x, n.y, n.z);
        colors.push(c.r, c.g, c.b);
      });
      indices.push(vi, vi + 1, vi + 2);
      vi += 3;
      // Triangle 2: p10, p11, p01
      [p10, p11, p01].forEach(p => {
        verts.push(p.x, p.y, p.z);
        normals.push(n.x, n.y, n.z);
        colors.push(c.r, c.g, c.b);
      });
      indices.push(vi, vi + 1, vi + 2);
      vi += 3;
    }
  }

  geo.setAttribute('position', new THREE.Float32BufferAttribute(verts, 3));
  geo.setAttribute('normal', new THREE.Float32BufferAttribute(normals, 3));
  geo.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
  geo.setIndex(indices);

  const mat = new THREE.MeshPhongMaterial({
    vertexColors: true,
    side: THREE.DoubleSide,
    shininess: 40,
    transparent: true,
    opacity: 0.92,
  });
  surfaceMesh = new THREE.Mesh(geo, mat);
  scene.add(surfaceMesh);

  // Wireframe grid on top
  const wireMat = new THREE.MeshBasicMaterial({ color: 0x000000, wireframe: true, transparent: true, opacity: 0.12 });
  edgesMesh = new THREE.Mesh(geo.clone(), wireMat);
  scene.add(edgesMesh);
}

function buildGrid() {
  // Floor grid & axis lines
  const lineMat = new THREE.LineBasicMaterial({ color: 0x2a4a6c, transparent: true, opacity: 0.5 });

  // Floor grid lines (RPM direction)
  for (let ri = 0; ri < afrMap.length; ri++) {
    const z = ri * GRID_D / (afrMap.length - 1);
    const pts = [new THREE.Vector3(0, 0, z), new THREE.Vector3(GRID_W, 0, z)];
    const geo = new THREE.BufferGeometry().setFromPoints(pts);
    scene.add(new THREE.Line(geo, lineMat));
  }
  // Floor grid lines (Load direction)
  for (let ci = 0; ci < afrMap[0].length; ci++) {
    const x = ci * GRID_W / (afrMap[0].length - 1);
    const pts = [new THREE.Vector3(x, 0, 0), new THREE.Vector3(x, 0, GRID_D)];
    const geo = new THREE.BufferGeometry().setFromPoints(pts);
    scene.add(new THREE.Line(geo, lineMat));
  }

  // Vertical drop lines at corners for depth perception
  const dropMat = new THREE.LineBasicMaterial({ color: 0x1a3a5c, transparent: true, opacity: 0.35 });
  for (let ri = 0; ri < afrMap.length; ri += 2) {
    for (let ci = 0; ci < afrMap[0].length; ci += 3) {
      const x = ci * GRID_W / (afrMap[0].length - 1);
      const z = ri * GRID_D / (afrMap.length - 1);
      const y = afrToY(afrMap[ri][ci]);
      const pts = [new THREE.Vector3(x, 0, z), new THREE.Vector3(x, y, z)];
      const geo = new THREE.BufferGeometry().setFromPoints(pts);
      scene.add(new THREE.Line(geo, dropMat));
    }
  }

  // Axis lines (bright)
  const axisMat = new THREE.LineBasicMaterial({ color: 0x4fc3f7, transparent: true, opacity: 0.7 });
  [
    [new THREE.Vector3(0, 0, 0), new THREE.Vector3(GRID_W, 0, 0)],
    [new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 0, GRID_D)],
    [new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, AFR_HEIGHT, 0)],
  ].forEach(pts => {
    const geo = new THREE.BufferGeometry().setFromPoints(pts);
    scene.add(new THREE.Line(geo, axisMat));
  });
}

function makeTextSprite(text, opts = {}) {
  const canvas = document.createElement('canvas');
  const sz = opts.size || 128;
  canvas.width = sz; canvas.height = sz / 2;
  const ctx = canvas.getContext('2d');
  ctx.fillStyle = opts.color || '#888888';
  ctx.font = `${opts.bold ? 'bold ' : ''}${opts.fontSize || 20}px -apple-system, sans-serif`;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText(text, canvas.width / 2, canvas.height / 2);
  const tex = new THREE.CanvasTexture(canvas);
  const mat = new THREE.SpriteMaterial({ map: tex, transparent: true, depthTest: false });
  const sprite = new THREE.Sprite(mat);
  sprite.scale.set(opts.scale || 0.8, (opts.scale || 0.8) * 0.5, 1);
  return sprite;
}

function buildLabels() {
  // RPM labels along X axis
  afrRpms.forEach((rpm, i) => {
    if (i % 2 !== 0) return;
    const x = i * GRID_W / (afrRpms.length - 1);
    const s = makeTextSprite(rpm.toString(), { fontSize: 18, scale: 0.7 });
    s.position.set(x, -0.25, -0.2);
    scene.add(s);
  });
  // RPM axis title
  const rpmTitle = makeTextSprite('RPM', { color: '#4fc3f7', bold: true, fontSize: 22, scale: 0.9 });
  rpmTitle.position.set(GRID_W / 2, -0.5, -0.4);
  scene.add(rpmTitle);

  // Load labels along Z axis
  afrLoads.forEach((lbl, i) => {
    const z = i * GRID_D / (afrLoads.length - 1);
    const s = makeTextSprite(lbl, { fontSize: 18, scale: 0.65 });
    s.position.set(-0.45, -0.25, z);
    scene.add(s);
  });
  // Load axis title
  const loadTitle = makeTextSprite('Load', { color: '#4fc3f7', bold: true, fontSize: 22, scale: 0.9 });
  loadTitle.position.set(-0.7, -0.5, GRID_D / 2);
  scene.add(loadTitle);

  // AFR labels on Y axis
  [11, 12, 13, 14, 15].forEach(afr => {
    const y = afrToY(afr);
    const s = makeTextSprite(afr.toFixed(1), { fontSize: 16, scale: 0.55 });
    s.position.set(-0.4, y, -0.15);
    scene.add(s);
    // tick line
    const tickMat = new THREE.LineBasicMaterial({ color: 0x2a4a6c, transparent: true, opacity: 0.3 });
    const pts = [new THREE.Vector3(-0.05, y, 0), new THREE.Vector3(GRID_W, y, 0)];
    const geo = new THREE.BufferGeometry().setFromPoints(pts);
    scene.add(new THREE.Line(geo, tickMat));
  });
  const afrTitle = makeTextSprite('AFR', { color: '#4fc3f7', bold: true, fontSize: 22, scale: 0.8 });
  afrTitle.position.set(-0.65, AFR_HEIGHT / 2, -0.3);
  scene.add(afrTitle);

  // AFR value labels floating above each cell center
  const rows = afrMap.length, cols = afrMap[0].length;
  for (let ri = 0; ri < rows; ri++) {
    for (let ci = 0; ci < cols; ci++) {
      const afr = afrMap[ri][ci];
      const x = ci * GRID_W / (cols - 1);
      const z = ri * GRID_D / (rows - 1);
      const y = afrToY(afr) + 0.12;
      const s = makeTextSprite(afr.toFixed(1), { fontSize: 15, scale: 0.38, color: '#ffffff', bold: true });
      s.position.set(x, y, z);
      s.userData.isAfrLabel = true;
      s.userData.row = ri;
      s.userData.col = ci;
      scene.add(s);
    }
  }
}

function updateHighlight() {
  // Remove old highlight
  if (hlMesh) { scene.remove(hlMesh); hlMesh = null; }

  // Dim/brighten AFR labels
  scene.children.forEach(c => {
    if (c.userData && c.userData.isAfrLabel) {
      if (activeCondition < 0) {
        c.material.opacity = 1;
      } else {
        const reg = conditionRegions[activeCondition];
        const rpm = afrRpms[c.userData.col];
        const inRegion = rpm >= reg.rpmMin && rpm <= reg.rpmMax && reg.rows.includes(c.userData.row);
        c.material.opacity = inRegion ? 1 : 0.15;
      }
    }
  });

  if (activeCondition < 0) {
    surfaceMesh.material.opacity = 0.92;
    return;
  }

  // Build highlight box
  const reg = conditionRegions[activeCondition];
  const cols = afrMap[0].length, rows = afrMap.length;
  const minC = afrRpms.findIndex(r => r >= reg.rpmMin);
  const maxC = afrRpms.length - 1 - [...afrRpms].reverse().findIndex(r => r <= reg.rpmMax);
  const minR = Math.min(...reg.rows), maxR = Math.max(...reg.rows);

  const x0 = minC * GRID_W / (cols - 1), x1 = maxC * GRID_W / (cols - 1);
  const z0 = minR * GRID_D / (rows - 1), z1 = maxR * GRID_D / (rows - 1);

  // Find Y range in region
  let yMin = Infinity, yMax = -Infinity;
  for (let ri = minR; ri <= maxR; ri++) {
    for (let ci = minC; ci <= maxC; ci++) {
      const y = afrToY(afrMap[ri][ci]);
      yMin = Math.min(yMin, y); yMax = Math.max(yMax, y);
    }
  }

  // Glowing wireframe box around region
  const pad = 0.02;
  const boxPts = [
    // Bottom rectangle
    new THREE.Vector3(x0 - pad, -pad, z0 - pad),
    new THREE.Vector3(x1 + pad, -pad, z0 - pad),
    new THREE.Vector3(x1 + pad, -pad, z1 + pad),
    new THREE.Vector3(x0 - pad, -pad, z1 + pad),
    new THREE.Vector3(x0 - pad, -pad, z0 - pad),
    // Up to top
    new THREE.Vector3(x0 - pad, yMax + 0.15, z0 - pad),
    new THREE.Vector3(x1 + pad, yMax + 0.15, z0 - pad),
    new THREE.Vector3(x1 + pad, yMax + 0.15, z1 + pad),
    new THREE.Vector3(x0 - pad, yMax + 0.15, z1 + pad),
    new THREE.Vector3(x0 - pad, yMax + 0.15, z0 - pad),
  ];
  const boxGeo = new THREE.BufferGeometry().setFromPoints(boxPts);
  hlMesh = new THREE.Line(boxGeo, new THREE.LineBasicMaterial({ color: 0x4fc3f7, linewidth: 2 }));
  scene.add(hlMesh);

  // Also add verticals
  const vertPts = [
    [new THREE.Vector3(x1 + pad, -pad, z0 - pad), new THREE.Vector3(x1 + pad, yMax + 0.15, z0 - pad)],
    [new THREE.Vector3(x1 + pad, -pad, z1 + pad), new THREE.Vector3(x1 + pad, yMax + 0.15, z1 + pad)],
    [new THREE.Vector3(x0 - pad, -pad, z1 + pad), new THREE.Vector3(x0 - pad, yMax + 0.15, z1 + pad)],
  ];
  vertPts.forEach(pts => {
    const g = new THREE.BufferGeometry().setFromPoints(pts);
    const l = new THREE.Line(g, new THREE.LineBasicMaterial({ color: 0x4fc3f7 }));
    l.userData.isHighlight = true;
    hlMesh.add(l);
  });

  surfaceMesh.material.opacity = 0.5;
}

function animate() {
  requestAnimationFrame(animate);
  renderer.render(scene, camera);
}

function setView(name) {
  switch (name) {
    case 'angle': camTheta = 0.8; camPhi = 0.55; camDist = 8.5; break;
    case 'top':   camTheta = 0; camPhi = 0.05; camDist = 9; break;
    case 'front': camTheta = 0; camPhi = 0.35; camDist = 9; break;
    case 'side':  camTheta = Math.PI / 2; camPhi = 0.35; camDist = 9; break;
  }
  updateCamera();
}

// Row click → highlight
document.querySelector('.afr-matrix')?.querySelector('tbody')?.addEventListener('click', function(e) {
  const tr = e.target.closest('tr');
  if (!tr) return;
  const rows = [...this.querySelectorAll('tr')];
  const idx = rows.indexOf(tr);
  if (idx < 0) return;
  rows.forEach(r => r.classList.remove('afr-active'));
  if (activeCondition === idx) {
    activeCondition = -1;
  } else {
    activeCondition = idx;
    tr.classList.add('afr-active');
  }
  updateHighlight();
});

// Resize handler
function resizeAfrScene() {
  const container = $('afrScene');
  if (!container || !renderer) return;
  const W = container.clientWidth;
  renderer.setSize(W, 380);
  camera.aspect = W / 380;
  camera.updateProjectionMatrix();
}

// ══════════ EVENTS ══════════

document.querySelectorAll('input, select').forEach(el => { el.addEventListener('input', calculate); el.addEventListener('change', calculate); });
window.addEventListener('resize', () => { calculate(); resizeAfrScene(); });
calculate();
initAfrScene();
</script>
</body>
</html>
